"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/form-data-encoder";
exports.ids = ["vendor-chunks/form-data-encoder"];
exports.modules = {

/***/ "(rsc)/./node_modules/form-data-encoder/lib/index.cjs":
/*!******************************************************!*\
  !*** ./node_modules/form-data-encoder/lib/index.cjs ***!
  \******************************************************/
/***/ ((module) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __typeError = (msg) => {\n  throw TypeError(msg);\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\nvar __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\nvar __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value);\nvar __privateMethod = (obj, member, method) => (__accessCheck(obj, member, \"access private method\"), method);\n\n// src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n  FormDataEncoder: () => FormDataEncoder,\n  isFile: () => isFile,\n  isFormData: () => isFormData\n});\nmodule.exports = __toCommonJS(src_exports);\n\n// src/util/chunk.ts\nvar MAX_CHUNK_SIZE = 65536;\nfunction* chunk(value) {\n  if (value.byteLength <= MAX_CHUNK_SIZE) {\n    yield value;\n    return;\n  }\n  let offset = 0;\n  while (offset < value.byteLength) {\n    const size = Math.min(value.byteLength - offset, MAX_CHUNK_SIZE);\n    const buffer = value.buffer.slice(offset, offset + size);\n    offset += buffer.byteLength;\n    yield new Uint8Array(buffer);\n  }\n}\n\n// src/util/createBoundary.ts\nvar alphabet = \"abcdefghijklmnopqrstuvwxyz0123456789\";\nfunction createBoundary() {\n  let size = 16;\n  let res = \"\";\n  while (size--) {\n    res += alphabet[Math.random() * alphabet.length << 0];\n  }\n  return res;\n}\n\n// src/util/escapeName.ts\nvar escapeName = (name) => String(name).replace(/\\r/g, \"%0D\").replace(/\\n/g, \"%0A\").replace(/\"/g, \"%22\");\n\n// src/util/isFunction.ts\nvar isFunction = (value) => typeof value === \"function\";\n\n// src/util/isReadableStreamFallback.ts\nvar isReadableStreamFallback = (value) => !!value && typeof value === \"object\" && !Array.isArray(value) && isFunction(value.getReader);\n\n// src/util/isAsyncIterable.ts\nvar isAsyncIterable = (value) => isFunction(value[Symbol.asyncIterator]);\n\n// src/util/getStreamIterator.ts\nasync function* readStream(readable) {\n  const reader = readable.getReader();\n  while (true) {\n    const { done, value } = await reader.read();\n    if (done) {\n      break;\n    }\n    yield value;\n  }\n}\nasync function* chunkStream(stream) {\n  for await (const value of stream) {\n    yield* chunk(value);\n  }\n}\nvar getStreamIterator = (source) => {\n  if (isAsyncIterable(source)) {\n    return chunkStream(source);\n  }\n  if (isReadableStreamFallback(source)) {\n    return chunkStream(readStream(source));\n  }\n  throw new TypeError(\n    \"Unsupported data source: Expected either ReadableStream or async iterable.\"\n  );\n};\n\n// src/util/isFile.ts\nvar isFile = (value) => Boolean(\n  value && typeof value === \"object\" && isFunction(value.constructor) && value[Symbol.toStringTag] === \"File\" && isFunction(value.stream) && value.name != null\n);\n\n// src/util/isFormData.ts\nvar isFormData = (value) => Boolean(\n  value && isFunction(value.constructor) && value[Symbol.toStringTag] === \"FormData\" && isFunction(value.append) && isFunction(value.getAll) && isFunction(value.entries) && isFunction(value[Symbol.iterator])\n);\n\n// src/util/isPlainObject.ts\nvar getType = (value) => Object.prototype.toString.call(value).slice(8, -1).toLowerCase();\nfunction isPlainObject(value) {\n  if (getType(value) !== \"object\") {\n    return false;\n  }\n  const pp = Object.getPrototypeOf(value);\n  if (pp === null || pp === void 0) {\n    return true;\n  }\n  return pp.constructor?.toString?.() === Object.toString();\n}\n\n// src/util/normalizeValue.ts\nvar normalizeValue = (value) => String(value).replace(/\\r|\\n/g, (match, i, str) => {\n  if (match === \"\\r\" && str[i + 1] !== \"\\n\" || match === \"\\n\" && str[i - 1] !== \"\\r\") {\n    return \"\\r\\n\";\n  }\n  return match;\n});\n\n// src/util/proxyHeaders.ts\nfunction getProperty(target, prop) {\n  if (typeof prop === \"string\") {\n    for (const [name, value] of Object.entries(target)) {\n      if (prop.toLowerCase() === name.toLowerCase()) {\n        return value;\n      }\n    }\n  }\n  return void 0;\n}\nvar proxyHeaders = (object) => new Proxy(\n  object,\n  {\n    get: (target, prop) => getProperty(target, prop),\n    has: (target, prop) => getProperty(target, prop) !== void 0\n  }\n);\n\n// src/FormDataEncoder.ts\nvar defaultOptions = {\n  enableAdditionalHeaders: false\n};\nvar readonlyProp = { writable: false, configurable: false };\nvar _CRLF, _CRLF_BYTES, _CRLF_BYTES_LENGTH, _DASHES, _encoder, _footer, _form, _options, _FormDataEncoder_instances, getFieldHeader_fn, getContentLength_fn;\nvar FormDataEncoder = class {\n  constructor(form, boundaryOrOptions, options) {\n    __privateAdd(this, _FormDataEncoder_instances);\n    __privateAdd(this, _CRLF, \"\\r\\n\");\n    __privateAdd(this, _CRLF_BYTES);\n    __privateAdd(this, _CRLF_BYTES_LENGTH);\n    __privateAdd(this, _DASHES, \"-\".repeat(2));\n    /**\n     * TextEncoder instance\n     */\n    __privateAdd(this, _encoder, new TextEncoder());\n    /**\n     * Returns form-data footer bytes\n     */\n    __privateAdd(this, _footer);\n    /**\n     * FormData instance\n     */\n    __privateAdd(this, _form);\n    /**\n     * Instance options\n     */\n    __privateAdd(this, _options);\n    if (!isFormData(form)) {\n      throw new TypeError(\"Expected first argument to be a FormData instance.\");\n    }\n    let boundary;\n    if (isPlainObject(boundaryOrOptions)) {\n      options = boundaryOrOptions;\n    } else {\n      boundary = boundaryOrOptions;\n    }\n    if (!boundary) {\n      boundary = `form-data-encoder-${createBoundary()}`;\n    }\n    if (typeof boundary !== \"string\") {\n      throw new TypeError(\"Expected boundary argument to be a string.\");\n    }\n    if (options && !isPlainObject(options)) {\n      throw new TypeError(\"Expected options argument to be an object.\");\n    }\n    __privateSet(this, _form, Array.from(form.entries()));\n    __privateSet(this, _options, { ...defaultOptions, ...options });\n    __privateSet(this, _CRLF_BYTES, __privateGet(this, _encoder).encode(__privateGet(this, _CRLF)));\n    __privateSet(this, _CRLF_BYTES_LENGTH, __privateGet(this, _CRLF_BYTES).byteLength);\n    this.boundary = boundary;\n    this.contentType = `multipart/form-data; boundary=${this.boundary}`;\n    __privateSet(this, _footer, __privateGet(this, _encoder).encode(\n      `${__privateGet(this, _DASHES)}${this.boundary}${__privateGet(this, _DASHES)}${__privateGet(this, _CRLF).repeat(2)}`\n    ));\n    const headers = {\n      \"Content-Type\": this.contentType\n    };\n    const contentLength = __privateMethod(this, _FormDataEncoder_instances, getContentLength_fn).call(this);\n    if (contentLength) {\n      this.contentLength = contentLength;\n      headers[\"Content-Length\"] = contentLength;\n    }\n    this.headers = proxyHeaders(Object.freeze(headers));\n    Object.defineProperties(this, {\n      boundary: readonlyProp,\n      contentType: readonlyProp,\n      contentLength: readonlyProp,\n      headers: readonlyProp\n    });\n  }\n  /**\n   * Creates an iterator allowing to go through form-data parts (with metadata).\n   * This method **will not** read the files and **will not** split values big into smaller chunks.\n   *\n   * Using this method, you can convert form-data content into Blob:\n   *\n   * @example\n   *\n   * ```ts\n   * import {Readable} from \"stream\"\n   *\n   * import {FormDataEncoder} from \"form-data-encoder\"\n   *\n   * import {FormData} from \"formdata-polyfill/esm-min.js\"\n   * import {fileFrom} from \"fetch-blob/form.js\"\n   * import {File} from \"fetch-blob/file.js\"\n   * import {Blob} from \"fetch-blob\"\n   *\n   * import fetch from \"node-fetch\"\n   *\n   * const form = new FormData()\n   *\n   * form.set(\"field\", \"Just a random string\")\n   * form.set(\"file\", new File([\"Using files is class amazing\"]))\n   * form.set(\"fileFromPath\", await fileFrom(\"path/to/a/file.txt\"))\n   *\n   * const encoder = new FormDataEncoder(form)\n   *\n   * const options = {\n   *   method: \"post\",\n   *   body: new Blob(encoder, {type: encoder.contentType})\n   * }\n   *\n   * const response = await fetch(\"https://httpbin.org/post\", options)\n   *\n   * console.log(await response.json())\n   * ```\n   */\n  *values() {\n    for (const [name, raw] of __privateGet(this, _form)) {\n      const value = isFile(raw) ? raw : __privateGet(this, _encoder).encode(normalizeValue(raw));\n      yield __privateMethod(this, _FormDataEncoder_instances, getFieldHeader_fn).call(this, name, value);\n      yield value;\n      yield __privateGet(this, _CRLF_BYTES);\n    }\n    yield __privateGet(this, _footer);\n  }\n  /**\n   * Creates an async iterator allowing to perform the encoding by portions.\n   * This method reads through files and splits big values into smaller pieces (65536 bytes per each).\n   *\n   * @example\n   *\n   * ```ts\n   * import {Readable} from \"stream\"\n   *\n   * import {FormData, File, fileFromPath} from \"formdata-node\"\n   * import {FormDataEncoder} from \"form-data-encoder\"\n   *\n   * import fetch from \"node-fetch\"\n   *\n   * const form = new FormData()\n   *\n   * form.set(\"field\", \"Just a random string\")\n   * form.set(\"file\", new File([\"Using files is class amazing\"], \"file.txt\"))\n   * form.set(\"fileFromPath\", await fileFromPath(\"path/to/a/file.txt\"))\n   *\n   * const encoder = new FormDataEncoder(form)\n   *\n   * const options = {\n   *   method: \"post\",\n   *   headers: encoder.headers,\n   *   body: Readable.from(encoder.encode()) // or Readable.from(encoder)\n   * }\n   *\n   * const response = await fetch(\"https://httpbin.org/post\", options)\n   *\n   * console.log(await response.json())\n   * ```\n   */\n  async *encode() {\n    for (const part of this.values()) {\n      if (isFile(part)) {\n        yield* getStreamIterator(part.stream());\n      } else {\n        yield* chunk(part);\n      }\n    }\n  }\n  /**\n   * Creates an iterator allowing to read through the encoder data using for...of loops\n   */\n  [Symbol.iterator]() {\n    return this.values();\n  }\n  /**\n   * Creates an **async** iterator allowing to read through the encoder data using for-await...of loops\n   */\n  [Symbol.asyncIterator]() {\n    return this.encode();\n  }\n};\n_CRLF = new WeakMap();\n_CRLF_BYTES = new WeakMap();\n_CRLF_BYTES_LENGTH = new WeakMap();\n_DASHES = new WeakMap();\n_encoder = new WeakMap();\n_footer = new WeakMap();\n_form = new WeakMap();\n_options = new WeakMap();\n_FormDataEncoder_instances = new WeakSet();\ngetFieldHeader_fn = function(name, value) {\n  let header = \"\";\n  header += `${__privateGet(this, _DASHES)}${this.boundary}${__privateGet(this, _CRLF)}`;\n  header += `Content-Disposition: form-data; name=\"${escapeName(name)}\"`;\n  if (isFile(value)) {\n    header += `; filename=\"${escapeName(value.name)}\"${__privateGet(this, _CRLF)}`;\n    header += `Content-Type: ${value.type || \"application/octet-stream\"}`;\n  }\n  if (__privateGet(this, _options).enableAdditionalHeaders === true) {\n    const size = isFile(value) ? value.size : value.byteLength;\n    if (size != null && !isNaN(size)) {\n      header += `${__privateGet(this, _CRLF)}Content-Length: ${size}`;\n    }\n  }\n  return __privateGet(this, _encoder).encode(`${header}${__privateGet(this, _CRLF).repeat(2)}`);\n};\n/**\n * Returns form-data content length\n */\ngetContentLength_fn = function() {\n  let length = 0;\n  for (const [name, raw] of __privateGet(this, _form)) {\n    const value = isFile(raw) ? raw : __privateGet(this, _encoder).encode(normalizeValue(raw));\n    const size = isFile(value) ? value.size : value.byteLength;\n    if (size == null || isNaN(size)) {\n      return void 0;\n    }\n    length += __privateMethod(this, _FormDataEncoder_instances, getFieldHeader_fn).call(this, name, value).byteLength;\n    length += size;\n    length += __privateGet(this, _CRLF_BYTES_LENGTH);\n  }\n  return String(length + __privateGet(this, _footer).byteLength);\n};\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZm9ybS1kYXRhLWVuY29kZXIvbGliL2luZGV4LmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQixhQUFhO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGlCQUFpQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLCtCQUErQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsV0FBVyxjQUFjO0FBQ3RFO0FBQ0EsU0FBUyw0QkFBNEIsRUFBRSxjQUFjLEVBQUUsNEJBQTRCLEVBQUUsb0NBQW9DO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCLGFBQWEsVUFBVTtBQUN2QixhQUFhLE1BQU07QUFDbkIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDBCQUEwQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0EsYUFBYSw4QkFBOEI7QUFDM0MsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNEJBQTRCLEVBQUUsY0FBYyxFQUFFLDBCQUEwQjtBQUN2Riw2Q0FBNkMsUUFBUSxpQkFBaUI7QUFDdEU7QUFDQSxpQkFBaUIsWUFBWSx1QkFBdUIsR0FBRywwQkFBMEI7QUFDakYsK0JBQStCLHlDQUF5QztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwwQkFBMEIsa0JBQWtCLEtBQUs7QUFDcEU7QUFDQTtBQUNBLGdEQUFnRCxPQUFPLEVBQUUsb0NBQW9DO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxDQUlMIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Zvcm0tZGF0YS1lbmNvZGVyL2xpYi9pbmRleC5janM/YTAxZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fdHlwZUVycm9yID0gKG1zZykgPT4ge1xuICB0aHJvdyBUeXBlRXJyb3IobXNnKTtcbn07XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0NvbW1vbkpTID0gKG1vZCkgPT4gX19jb3B5UHJvcHMoX19kZWZQcm9wKHt9LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KSwgbW9kKTtcbnZhciBfX2FjY2Vzc0NoZWNrID0gKG9iaiwgbWVtYmVyLCBtc2cpID0+IG1lbWJlci5oYXMob2JqKSB8fCBfX3R5cGVFcnJvcihcIkNhbm5vdCBcIiArIG1zZyk7XG52YXIgX19wcml2YXRlR2V0ID0gKG9iaiwgbWVtYmVyLCBnZXR0ZXIpID0+IChfX2FjY2Vzc0NoZWNrKG9iaiwgbWVtYmVyLCBcInJlYWQgZnJvbSBwcml2YXRlIGZpZWxkXCIpLCBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogbWVtYmVyLmdldChvYmopKTtcbnZhciBfX3ByaXZhdGVBZGQgPSAob2JqLCBtZW1iZXIsIHZhbHVlKSA9PiBtZW1iZXIuaGFzKG9iaikgPyBfX3R5cGVFcnJvcihcIkNhbm5vdCBhZGQgdGhlIHNhbWUgcHJpdmF0ZSBtZW1iZXIgbW9yZSB0aGFuIG9uY2VcIikgOiBtZW1iZXIgaW5zdGFuY2VvZiBXZWFrU2V0ID8gbWVtYmVyLmFkZChvYmopIDogbWVtYmVyLnNldChvYmosIHZhbHVlKTtcbnZhciBfX3ByaXZhdGVTZXQgPSAob2JqLCBtZW1iZXIsIHZhbHVlLCBzZXR0ZXIpID0+IChfX2FjY2Vzc0NoZWNrKG9iaiwgbWVtYmVyLCBcIndyaXRlIHRvIHByaXZhdGUgZmllbGRcIiksIHNldHRlciA/IHNldHRlci5jYWxsKG9iaiwgdmFsdWUpIDogbWVtYmVyLnNldChvYmosIHZhbHVlKSwgdmFsdWUpO1xudmFyIF9fcHJpdmF0ZU1ldGhvZCA9IChvYmosIG1lbWJlciwgbWV0aG9kKSA9PiAoX19hY2Nlc3NDaGVjayhvYmosIG1lbWJlciwgXCJhY2Nlc3MgcHJpdmF0ZSBtZXRob2RcIiksIG1ldGhvZCk7XG5cbi8vIHNyYy9pbmRleC50c1xudmFyIHNyY19leHBvcnRzID0ge307XG5fX2V4cG9ydChzcmNfZXhwb3J0cywge1xuICBGb3JtRGF0YUVuY29kZXI6ICgpID0+IEZvcm1EYXRhRW5jb2RlcixcbiAgaXNGaWxlOiAoKSA9PiBpc0ZpbGUsXG4gIGlzRm9ybURhdGE6ICgpID0+IGlzRm9ybURhdGFcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBfX3RvQ29tbW9uSlMoc3JjX2V4cG9ydHMpO1xuXG4vLyBzcmMvdXRpbC9jaHVuay50c1xudmFyIE1BWF9DSFVOS19TSVpFID0gNjU1MzY7XG5mdW5jdGlvbiogY2h1bmsodmFsdWUpIHtcbiAgaWYgKHZhbHVlLmJ5dGVMZW5ndGggPD0gTUFYX0NIVU5LX1NJWkUpIHtcbiAgICB5aWVsZCB2YWx1ZTtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IG9mZnNldCA9IDA7XG4gIHdoaWxlIChvZmZzZXQgPCB2YWx1ZS5ieXRlTGVuZ3RoKSB7XG4gICAgY29uc3Qgc2l6ZSA9IE1hdGgubWluKHZhbHVlLmJ5dGVMZW5ndGggLSBvZmZzZXQsIE1BWF9DSFVOS19TSVpFKTtcbiAgICBjb25zdCBidWZmZXIgPSB2YWx1ZS5idWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBzaXplKTtcbiAgICBvZmZzZXQgKz0gYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgeWllbGQgbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgfVxufVxuXG4vLyBzcmMvdXRpbC9jcmVhdGVCb3VuZGFyeS50c1xudmFyIGFscGhhYmV0ID0gXCJhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODlcIjtcbmZ1bmN0aW9uIGNyZWF0ZUJvdW5kYXJ5KCkge1xuICBsZXQgc2l6ZSA9IDE2O1xuICBsZXQgcmVzID0gXCJcIjtcbiAgd2hpbGUgKHNpemUtLSkge1xuICAgIHJlcyArPSBhbHBoYWJldFtNYXRoLnJhbmRvbSgpICogYWxwaGFiZXQubGVuZ3RoIDw8IDBdO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8vIHNyYy91dGlsL2VzY2FwZU5hbWUudHNcbnZhciBlc2NhcGVOYW1lID0gKG5hbWUpID0+IFN0cmluZyhuYW1lKS5yZXBsYWNlKC9cXHIvZywgXCIlMERcIikucmVwbGFjZSgvXFxuL2csIFwiJTBBXCIpLnJlcGxhY2UoL1wiL2csIFwiJTIyXCIpO1xuXG4vLyBzcmMvdXRpbC9pc0Z1bmN0aW9uLnRzXG52YXIgaXNGdW5jdGlvbiA9ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCI7XG5cbi8vIHNyYy91dGlsL2lzUmVhZGFibGVTdHJlYW1GYWxsYmFjay50c1xudmFyIGlzUmVhZGFibGVTdHJlYW1GYWxsYmFjayA9ICh2YWx1ZSkgPT4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpICYmIGlzRnVuY3Rpb24odmFsdWUuZ2V0UmVhZGVyKTtcblxuLy8gc3JjL3V0aWwvaXNBc3luY0l0ZXJhYmxlLnRzXG52YXIgaXNBc3luY0l0ZXJhYmxlID0gKHZhbHVlKSA9PiBpc0Z1bmN0aW9uKHZhbHVlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSk7XG5cbi8vIHNyYy91dGlsL2dldFN0cmVhbUl0ZXJhdG9yLnRzXG5hc3luYyBmdW5jdGlvbiogcmVhZFN0cmVhbShyZWFkYWJsZSkge1xuICBjb25zdCByZWFkZXIgPSByZWFkYWJsZS5nZXRSZWFkZXIoKTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgIGlmIChkb25lKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgeWllbGQgdmFsdWU7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uKiBjaHVua1N0cmVhbShzdHJlYW0pIHtcbiAgZm9yIGF3YWl0IChjb25zdCB2YWx1ZSBvZiBzdHJlYW0pIHtcbiAgICB5aWVsZCogY2h1bmsodmFsdWUpO1xuICB9XG59XG52YXIgZ2V0U3RyZWFtSXRlcmF0b3IgPSAoc291cmNlKSA9PiB7XG4gIGlmIChpc0FzeW5jSXRlcmFibGUoc291cmNlKSkge1xuICAgIHJldHVybiBjaHVua1N0cmVhbShzb3VyY2UpO1xuICB9XG4gIGlmIChpc1JlYWRhYmxlU3RyZWFtRmFsbGJhY2soc291cmNlKSkge1xuICAgIHJldHVybiBjaHVua1N0cmVhbShyZWFkU3RyZWFtKHNvdXJjZSkpO1xuICB9XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgXCJVbnN1cHBvcnRlZCBkYXRhIHNvdXJjZTogRXhwZWN0ZWQgZWl0aGVyIFJlYWRhYmxlU3RyZWFtIG9yIGFzeW5jIGl0ZXJhYmxlLlwiXG4gICk7XG59O1xuXG4vLyBzcmMvdXRpbC9pc0ZpbGUudHNcbnZhciBpc0ZpbGUgPSAodmFsdWUpID0+IEJvb2xlYW4oXG4gIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiBpc0Z1bmN0aW9uKHZhbHVlLmNvbnN0cnVjdG9yKSAmJiB2YWx1ZVtTeW1ib2wudG9TdHJpbmdUYWddID09PSBcIkZpbGVcIiAmJiBpc0Z1bmN0aW9uKHZhbHVlLnN0cmVhbSkgJiYgdmFsdWUubmFtZSAhPSBudWxsXG4pO1xuXG4vLyBzcmMvdXRpbC9pc0Zvcm1EYXRhLnRzXG52YXIgaXNGb3JtRGF0YSA9ICh2YWx1ZSkgPT4gQm9vbGVhbihcbiAgdmFsdWUgJiYgaXNGdW5jdGlvbih2YWx1ZS5jb25zdHJ1Y3RvcikgJiYgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gXCJGb3JtRGF0YVwiICYmIGlzRnVuY3Rpb24odmFsdWUuYXBwZW5kKSAmJiBpc0Z1bmN0aW9uKHZhbHVlLmdldEFsbCkgJiYgaXNGdW5jdGlvbih2YWx1ZS5lbnRyaWVzKSAmJiBpc0Z1bmN0aW9uKHZhbHVlW1N5bWJvbC5pdGVyYXRvcl0pXG4pO1xuXG4vLyBzcmMvdXRpbC9pc1BsYWluT2JqZWN0LnRzXG52YXIgZ2V0VHlwZSA9ICh2YWx1ZSkgPT4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSkudG9Mb3dlckNhc2UoKTtcbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgaWYgKGdldFR5cGUodmFsdWUpICE9PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHBwID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKTtcbiAgaWYgKHBwID09PSBudWxsIHx8IHBwID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcHAuY29uc3RydWN0b3I/LnRvU3RyaW5nPy4oKSA9PT0gT2JqZWN0LnRvU3RyaW5nKCk7XG59XG5cbi8vIHNyYy91dGlsL25vcm1hbGl6ZVZhbHVlLnRzXG52YXIgbm9ybWFsaXplVmFsdWUgPSAodmFsdWUpID0+IFN0cmluZyh2YWx1ZSkucmVwbGFjZSgvXFxyfFxcbi9nLCAobWF0Y2gsIGksIHN0cikgPT4ge1xuICBpZiAobWF0Y2ggPT09IFwiXFxyXCIgJiYgc3RyW2kgKyAxXSAhPT0gXCJcXG5cIiB8fCBtYXRjaCA9PT0gXCJcXG5cIiAmJiBzdHJbaSAtIDFdICE9PSBcIlxcclwiKSB7XG4gICAgcmV0dXJuIFwiXFxyXFxuXCI7XG4gIH1cbiAgcmV0dXJuIG1hdGNoO1xufSk7XG5cbi8vIHNyYy91dGlsL3Byb3h5SGVhZGVycy50c1xuZnVuY3Rpb24gZ2V0UHJvcGVydHkodGFyZ2V0LCBwcm9wKSB7XG4gIGlmICh0eXBlb2YgcHJvcCA9PT0gXCJzdHJpbmdcIikge1xuICAgIGZvciAoY29uc3QgW25hbWUsIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh0YXJnZXQpKSB7XG4gICAgICBpZiAocHJvcC50b0xvd2VyQ2FzZSgpID09PSBuYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdm9pZCAwO1xufVxudmFyIHByb3h5SGVhZGVycyA9IChvYmplY3QpID0+IG5ldyBQcm94eShcbiAgb2JqZWN0LFxuICB7XG4gICAgZ2V0OiAodGFyZ2V0LCBwcm9wKSA9PiBnZXRQcm9wZXJ0eSh0YXJnZXQsIHByb3ApLFxuICAgIGhhczogKHRhcmdldCwgcHJvcCkgPT4gZ2V0UHJvcGVydHkodGFyZ2V0LCBwcm9wKSAhPT0gdm9pZCAwXG4gIH1cbik7XG5cbi8vIHNyYy9Gb3JtRGF0YUVuY29kZXIudHNcbnZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgZW5hYmxlQWRkaXRpb25hbEhlYWRlcnM6IGZhbHNlXG59O1xudmFyIHJlYWRvbmx5UHJvcCA9IHsgd3JpdGFibGU6IGZhbHNlLCBjb25maWd1cmFibGU6IGZhbHNlIH07XG52YXIgX0NSTEYsIF9DUkxGX0JZVEVTLCBfQ1JMRl9CWVRFU19MRU5HVEgsIF9EQVNIRVMsIF9lbmNvZGVyLCBfZm9vdGVyLCBfZm9ybSwgX29wdGlvbnMsIF9Gb3JtRGF0YUVuY29kZXJfaW5zdGFuY2VzLCBnZXRGaWVsZEhlYWRlcl9mbiwgZ2V0Q29udGVudExlbmd0aF9mbjtcbnZhciBGb3JtRGF0YUVuY29kZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGZvcm0sIGJvdW5kYXJ5T3JPcHRpb25zLCBvcHRpb25zKSB7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9Gb3JtRGF0YUVuY29kZXJfaW5zdGFuY2VzKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX0NSTEYsIFwiXFxyXFxuXCIpO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfQ1JMRl9CWVRFUyk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9DUkxGX0JZVEVTX0xFTkdUSCk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9EQVNIRVMsIFwiLVwiLnJlcGVhdCgyKSk7XG4gICAgLyoqXG4gICAgICogVGV4dEVuY29kZXIgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2VuY29kZXIsIG5ldyBUZXh0RW5jb2RlcigpKTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGZvcm0tZGF0YSBmb290ZXIgYnl0ZXNcbiAgICAgKi9cbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2Zvb3Rlcik7XG4gICAgLyoqXG4gICAgICogRm9ybURhdGEgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2Zvcm0pO1xuICAgIC8qKlxuICAgICAqIEluc3RhbmNlIG9wdGlvbnNcbiAgICAgKi9cbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX29wdGlvbnMpO1xuICAgIGlmICghaXNGb3JtRGF0YShmb3JtKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGZpcnN0IGFyZ3VtZW50IHRvIGJlIGEgRm9ybURhdGEgaW5zdGFuY2UuXCIpO1xuICAgIH1cbiAgICBsZXQgYm91bmRhcnk7XG4gICAgaWYgKGlzUGxhaW5PYmplY3QoYm91bmRhcnlPck9wdGlvbnMpKSB7XG4gICAgICBvcHRpb25zID0gYm91bmRhcnlPck9wdGlvbnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJvdW5kYXJ5ID0gYm91bmRhcnlPck9wdGlvbnM7XG4gICAgfVxuICAgIGlmICghYm91bmRhcnkpIHtcbiAgICAgIGJvdW5kYXJ5ID0gYGZvcm0tZGF0YS1lbmNvZGVyLSR7Y3JlYXRlQm91bmRhcnkoKX1gO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGJvdW5kYXJ5ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgYm91bmRhcnkgYXJndW1lbnQgdG8gYmUgYSBzdHJpbmcuXCIpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucyAmJiAhaXNQbGFpbk9iamVjdChvcHRpb25zKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIG9wdGlvbnMgYXJndW1lbnQgdG8gYmUgYW4gb2JqZWN0LlwiKTtcbiAgICB9XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9mb3JtLCBBcnJheS5mcm9tKGZvcm0uZW50cmllcygpKSk7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9vcHRpb25zLCB7IC4uLmRlZmF1bHRPcHRpb25zLCAuLi5vcHRpb25zIH0pO1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfQ1JMRl9CWVRFUywgX19wcml2YXRlR2V0KHRoaXMsIF9lbmNvZGVyKS5lbmNvZGUoX19wcml2YXRlR2V0KHRoaXMsIF9DUkxGKSkpO1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfQ1JMRl9CWVRFU19MRU5HVEgsIF9fcHJpdmF0ZUdldCh0aGlzLCBfQ1JMRl9CWVRFUykuYnl0ZUxlbmd0aCk7XG4gICAgdGhpcy5ib3VuZGFyeSA9IGJvdW5kYXJ5O1xuICAgIHRoaXMuY29udGVudFR5cGUgPSBgbXVsdGlwYXJ0L2Zvcm0tZGF0YTsgYm91bmRhcnk9JHt0aGlzLmJvdW5kYXJ5fWA7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9mb290ZXIsIF9fcHJpdmF0ZUdldCh0aGlzLCBfZW5jb2RlcikuZW5jb2RlKFxuICAgICAgYCR7X19wcml2YXRlR2V0KHRoaXMsIF9EQVNIRVMpfSR7dGhpcy5ib3VuZGFyeX0ke19fcHJpdmF0ZUdldCh0aGlzLCBfREFTSEVTKX0ke19fcHJpdmF0ZUdldCh0aGlzLCBfQ1JMRikucmVwZWF0KDIpfWBcbiAgICApKTtcbiAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgXCJDb250ZW50LVR5cGVcIjogdGhpcy5jb250ZW50VHlwZVxuICAgIH07XG4gICAgY29uc3QgY29udGVudExlbmd0aCA9IF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfRm9ybURhdGFFbmNvZGVyX2luc3RhbmNlcywgZ2V0Q29udGVudExlbmd0aF9mbikuY2FsbCh0aGlzKTtcbiAgICBpZiAoY29udGVudExlbmd0aCkge1xuICAgICAgdGhpcy5jb250ZW50TGVuZ3RoID0gY29udGVudExlbmd0aDtcbiAgICAgIGhlYWRlcnNbXCJDb250ZW50LUxlbmd0aFwiXSA9IGNvbnRlbnRMZW5ndGg7XG4gICAgfVxuICAgIHRoaXMuaGVhZGVycyA9IHByb3h5SGVhZGVycyhPYmplY3QuZnJlZXplKGhlYWRlcnMpKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICBib3VuZGFyeTogcmVhZG9ubHlQcm9wLFxuICAgICAgY29udGVudFR5cGU6IHJlYWRvbmx5UHJvcCxcbiAgICAgIGNvbnRlbnRMZW5ndGg6IHJlYWRvbmx5UHJvcCxcbiAgICAgIGhlYWRlcnM6IHJlYWRvbmx5UHJvcFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGl0ZXJhdG9yIGFsbG93aW5nIHRvIGdvIHRocm91Z2ggZm9ybS1kYXRhIHBhcnRzICh3aXRoIG1ldGFkYXRhKS5cbiAgICogVGhpcyBtZXRob2QgKip3aWxsIG5vdCoqIHJlYWQgdGhlIGZpbGVzIGFuZCAqKndpbGwgbm90Kiogc3BsaXQgdmFsdWVzIGJpZyBpbnRvIHNtYWxsZXIgY2h1bmtzLlxuICAgKlxuICAgKiBVc2luZyB0aGlzIG1ldGhvZCwgeW91IGNhbiBjb252ZXJ0IGZvcm0tZGF0YSBjb250ZW50IGludG8gQmxvYjpcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogYGBgdHNcbiAgICogaW1wb3J0IHtSZWFkYWJsZX0gZnJvbSBcInN0cmVhbVwiXG4gICAqXG4gICAqIGltcG9ydCB7Rm9ybURhdGFFbmNvZGVyfSBmcm9tIFwiZm9ybS1kYXRhLWVuY29kZXJcIlxuICAgKlxuICAgKiBpbXBvcnQge0Zvcm1EYXRhfSBmcm9tIFwiZm9ybWRhdGEtcG9seWZpbGwvZXNtLW1pbi5qc1wiXG4gICAqIGltcG9ydCB7ZmlsZUZyb219IGZyb20gXCJmZXRjaC1ibG9iL2Zvcm0uanNcIlxuICAgKiBpbXBvcnQge0ZpbGV9IGZyb20gXCJmZXRjaC1ibG9iL2ZpbGUuanNcIlxuICAgKiBpbXBvcnQge0Jsb2J9IGZyb20gXCJmZXRjaC1ibG9iXCJcbiAgICpcbiAgICogaW1wb3J0IGZldGNoIGZyb20gXCJub2RlLWZldGNoXCJcbiAgICpcbiAgICogY29uc3QgZm9ybSA9IG5ldyBGb3JtRGF0YSgpXG4gICAqXG4gICAqIGZvcm0uc2V0KFwiZmllbGRcIiwgXCJKdXN0IGEgcmFuZG9tIHN0cmluZ1wiKVxuICAgKiBmb3JtLnNldChcImZpbGVcIiwgbmV3IEZpbGUoW1wiVXNpbmcgZmlsZXMgaXMgY2xhc3MgYW1hemluZ1wiXSkpXG4gICAqIGZvcm0uc2V0KFwiZmlsZUZyb21QYXRoXCIsIGF3YWl0IGZpbGVGcm9tKFwicGF0aC90by9hL2ZpbGUudHh0XCIpKVxuICAgKlxuICAgKiBjb25zdCBlbmNvZGVyID0gbmV3IEZvcm1EYXRhRW5jb2Rlcihmb3JtKVxuICAgKlxuICAgKiBjb25zdCBvcHRpb25zID0ge1xuICAgKiAgIG1ldGhvZDogXCJwb3N0XCIsXG4gICAqICAgYm9keTogbmV3IEJsb2IoZW5jb2Rlciwge3R5cGU6IGVuY29kZXIuY29udGVudFR5cGV9KVxuICAgKiB9XG4gICAqXG4gICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXCJodHRwczovL2h0dHBiaW4ub3JnL3Bvc3RcIiwgb3B0aW9ucylcbiAgICpcbiAgICogY29uc29sZS5sb2coYXdhaXQgcmVzcG9uc2UuanNvbigpKVxuICAgKiBgYGBcbiAgICovXG4gICp2YWx1ZXMoKSB7XG4gICAgZm9yIChjb25zdCBbbmFtZSwgcmF3XSBvZiBfX3ByaXZhdGVHZXQodGhpcywgX2Zvcm0pKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGlzRmlsZShyYXcpID8gcmF3IDogX19wcml2YXRlR2V0KHRoaXMsIF9lbmNvZGVyKS5lbmNvZGUobm9ybWFsaXplVmFsdWUocmF3KSk7XG4gICAgICB5aWVsZCBfX3ByaXZhdGVNZXRob2QodGhpcywgX0Zvcm1EYXRhRW5jb2Rlcl9pbnN0YW5jZXMsIGdldEZpZWxkSGVhZGVyX2ZuKS5jYWxsKHRoaXMsIG5hbWUsIHZhbHVlKTtcbiAgICAgIHlpZWxkIHZhbHVlO1xuICAgICAgeWllbGQgX19wcml2YXRlR2V0KHRoaXMsIF9DUkxGX0JZVEVTKTtcbiAgICB9XG4gICAgeWllbGQgX19wcml2YXRlR2V0KHRoaXMsIF9mb290ZXIpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGFzeW5jIGl0ZXJhdG9yIGFsbG93aW5nIHRvIHBlcmZvcm0gdGhlIGVuY29kaW5nIGJ5IHBvcnRpb25zLlxuICAgKiBUaGlzIG1ldGhvZCByZWFkcyB0aHJvdWdoIGZpbGVzIGFuZCBzcGxpdHMgYmlnIHZhbHVlcyBpbnRvIHNtYWxsZXIgcGllY2VzICg2NTUzNiBieXRlcyBwZXIgZWFjaCkuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIGBgYHRzXG4gICAqIGltcG9ydCB7UmVhZGFibGV9IGZyb20gXCJzdHJlYW1cIlxuICAgKlxuICAgKiBpbXBvcnQge0Zvcm1EYXRhLCBGaWxlLCBmaWxlRnJvbVBhdGh9IGZyb20gXCJmb3JtZGF0YS1ub2RlXCJcbiAgICogaW1wb3J0IHtGb3JtRGF0YUVuY29kZXJ9IGZyb20gXCJmb3JtLWRhdGEtZW5jb2RlclwiXG4gICAqXG4gICAqIGltcG9ydCBmZXRjaCBmcm9tIFwibm9kZS1mZXRjaFwiXG4gICAqXG4gICAqIGNvbnN0IGZvcm0gPSBuZXcgRm9ybURhdGEoKVxuICAgKlxuICAgKiBmb3JtLnNldChcImZpZWxkXCIsIFwiSnVzdCBhIHJhbmRvbSBzdHJpbmdcIilcbiAgICogZm9ybS5zZXQoXCJmaWxlXCIsIG5ldyBGaWxlKFtcIlVzaW5nIGZpbGVzIGlzIGNsYXNzIGFtYXppbmdcIl0sIFwiZmlsZS50eHRcIikpXG4gICAqIGZvcm0uc2V0KFwiZmlsZUZyb21QYXRoXCIsIGF3YWl0IGZpbGVGcm9tUGF0aChcInBhdGgvdG8vYS9maWxlLnR4dFwiKSlcbiAgICpcbiAgICogY29uc3QgZW5jb2RlciA9IG5ldyBGb3JtRGF0YUVuY29kZXIoZm9ybSlcbiAgICpcbiAgICogY29uc3Qgb3B0aW9ucyA9IHtcbiAgICogICBtZXRob2Q6IFwicG9zdFwiLFxuICAgKiAgIGhlYWRlcnM6IGVuY29kZXIuaGVhZGVycyxcbiAgICogICBib2R5OiBSZWFkYWJsZS5mcm9tKGVuY29kZXIuZW5jb2RlKCkpIC8vIG9yIFJlYWRhYmxlLmZyb20oZW5jb2RlcilcbiAgICogfVxuICAgKlxuICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFwiaHR0cHM6Ly9odHRwYmluLm9yZy9wb3N0XCIsIG9wdGlvbnMpXG4gICAqXG4gICAqIGNvbnNvbGUubG9nKGF3YWl0IHJlc3BvbnNlLmpzb24oKSlcbiAgICogYGBgXG4gICAqL1xuICBhc3luYyAqZW5jb2RlKCkge1xuICAgIGZvciAoY29uc3QgcGFydCBvZiB0aGlzLnZhbHVlcygpKSB7XG4gICAgICBpZiAoaXNGaWxlKHBhcnQpKSB7XG4gICAgICAgIHlpZWxkKiBnZXRTdHJlYW1JdGVyYXRvcihwYXJ0LnN0cmVhbSgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHlpZWxkKiBjaHVuayhwYXJ0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaXRlcmF0b3IgYWxsb3dpbmcgdG8gcmVhZCB0aHJvdWdoIHRoZSBlbmNvZGVyIGRhdGEgdXNpbmcgZm9yLi4ub2YgbG9vcHNcbiAgICovXG4gIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlcygpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuICoqYXN5bmMqKiBpdGVyYXRvciBhbGxvd2luZyB0byByZWFkIHRocm91Z2ggdGhlIGVuY29kZXIgZGF0YSB1c2luZyBmb3ItYXdhaXQuLi5vZiBsb29wc1xuICAgKi9cbiAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICByZXR1cm4gdGhpcy5lbmNvZGUoKTtcbiAgfVxufTtcbl9DUkxGID0gbmV3IFdlYWtNYXAoKTtcbl9DUkxGX0JZVEVTID0gbmV3IFdlYWtNYXAoKTtcbl9DUkxGX0JZVEVTX0xFTkdUSCA9IG5ldyBXZWFrTWFwKCk7XG5fREFTSEVTID0gbmV3IFdlYWtNYXAoKTtcbl9lbmNvZGVyID0gbmV3IFdlYWtNYXAoKTtcbl9mb290ZXIgPSBuZXcgV2Vha01hcCgpO1xuX2Zvcm0gPSBuZXcgV2Vha01hcCgpO1xuX29wdGlvbnMgPSBuZXcgV2Vha01hcCgpO1xuX0Zvcm1EYXRhRW5jb2Rlcl9pbnN0YW5jZXMgPSBuZXcgV2Vha1NldCgpO1xuZ2V0RmllbGRIZWFkZXJfZm4gPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICBsZXQgaGVhZGVyID0gXCJcIjtcbiAgaGVhZGVyICs9IGAke19fcHJpdmF0ZUdldCh0aGlzLCBfREFTSEVTKX0ke3RoaXMuYm91bmRhcnl9JHtfX3ByaXZhdGVHZXQodGhpcywgX0NSTEYpfWA7XG4gIGhlYWRlciArPSBgQ29udGVudC1EaXNwb3NpdGlvbjogZm9ybS1kYXRhOyBuYW1lPVwiJHtlc2NhcGVOYW1lKG5hbWUpfVwiYDtcbiAgaWYgKGlzRmlsZSh2YWx1ZSkpIHtcbiAgICBoZWFkZXIgKz0gYDsgZmlsZW5hbWU9XCIke2VzY2FwZU5hbWUodmFsdWUubmFtZSl9XCIke19fcHJpdmF0ZUdldCh0aGlzLCBfQ1JMRil9YDtcbiAgICBoZWFkZXIgKz0gYENvbnRlbnQtVHlwZTogJHt2YWx1ZS50eXBlIHx8IFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCJ9YDtcbiAgfVxuICBpZiAoX19wcml2YXRlR2V0KHRoaXMsIF9vcHRpb25zKS5lbmFibGVBZGRpdGlvbmFsSGVhZGVycyA9PT0gdHJ1ZSkge1xuICAgIGNvbnN0IHNpemUgPSBpc0ZpbGUodmFsdWUpID8gdmFsdWUuc2l6ZSA6IHZhbHVlLmJ5dGVMZW5ndGg7XG4gICAgaWYgKHNpemUgIT0gbnVsbCAmJiAhaXNOYU4oc2l6ZSkpIHtcbiAgICAgIGhlYWRlciArPSBgJHtfX3ByaXZhdGVHZXQodGhpcywgX0NSTEYpfUNvbnRlbnQtTGVuZ3RoOiAke3NpemV9YDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfZW5jb2RlcikuZW5jb2RlKGAke2hlYWRlcn0ke19fcHJpdmF0ZUdldCh0aGlzLCBfQ1JMRikucmVwZWF0KDIpfWApO1xufTtcbi8qKlxuICogUmV0dXJucyBmb3JtLWRhdGEgY29udGVudCBsZW5ndGhcbiAqL1xuZ2V0Q29udGVudExlbmd0aF9mbiA9IGZ1bmN0aW9uKCkge1xuICBsZXQgbGVuZ3RoID0gMDtcbiAgZm9yIChjb25zdCBbbmFtZSwgcmF3XSBvZiBfX3ByaXZhdGVHZXQodGhpcywgX2Zvcm0pKSB7XG4gICAgY29uc3QgdmFsdWUgPSBpc0ZpbGUocmF3KSA/IHJhdyA6IF9fcHJpdmF0ZUdldCh0aGlzLCBfZW5jb2RlcikuZW5jb2RlKG5vcm1hbGl6ZVZhbHVlKHJhdykpO1xuICAgIGNvbnN0IHNpemUgPSBpc0ZpbGUodmFsdWUpID8gdmFsdWUuc2l6ZSA6IHZhbHVlLmJ5dGVMZW5ndGg7XG4gICAgaWYgKHNpemUgPT0gbnVsbCB8fCBpc05hTihzaXplKSkge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgbGVuZ3RoICs9IF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfRm9ybURhdGFFbmNvZGVyX2luc3RhbmNlcywgZ2V0RmllbGRIZWFkZXJfZm4pLmNhbGwodGhpcywgbmFtZSwgdmFsdWUpLmJ5dGVMZW5ndGg7XG4gICAgbGVuZ3RoICs9IHNpemU7XG4gICAgbGVuZ3RoICs9IF9fcHJpdmF0ZUdldCh0aGlzLCBfQ1JMRl9CWVRFU19MRU5HVEgpO1xuICB9XG4gIHJldHVybiBTdHJpbmcobGVuZ3RoICsgX19wcml2YXRlR2V0KHRoaXMsIF9mb290ZXIpLmJ5dGVMZW5ndGgpO1xufTtcbi8vIEFubm90YXRlIHRoZSBDb21tb25KUyBleHBvcnQgbmFtZXMgZm9yIEVTTSBpbXBvcnQgaW4gbm9kZTpcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICBGb3JtRGF0YUVuY29kZXIsXG4gIGlzRmlsZSxcbiAgaXNGb3JtRGF0YVxufSk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/form-data-encoder/lib/index.cjs\n");

/***/ })

};
;