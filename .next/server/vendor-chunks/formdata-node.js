"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/formdata-node";
exports.ids = ["vendor-chunks/formdata-node"];
exports.modules = {

/***/ "(rsc)/./node_modules/formdata-node/lib/form-data.cjs":
/*!******************************************************!*\
  !*** ./node_modules/formdata-node/lib/form-data.cjs ***!
  \******************************************************/
/***/ ((module) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar __privateMethod = (obj, member, method) => {\n  __accessCheck(obj, member, \"access private method\");\n  return method;\n};\n\n// src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n  Blob: () => Blob,\n  File: () => File,\n  FormData: () => FormData\n});\nmodule.exports = __toCommonJS(src_exports);\n\n// src/isFunction.ts\nvar isFunction = (value) => typeof value === \"function\";\n\n// src/isObject.ts\nvar isObject = (value) => typeof value === \"object\" && value != null && !Array.isArray(value);\n\n// src/isAsyncIterable.ts\nvar isAsyncIterable = (value) => isObject(value) && isFunction(value[Symbol.asyncIterator]);\n\n// src/blobHelpers.ts\nvar MAX_CHUNK_SIZE = 65536;\nasync function* clonePart(value) {\n  if (value.byteLength <= MAX_CHUNK_SIZE) {\n    yield value;\n    return;\n  }\n  let offset = 0;\n  while (offset < value.byteLength) {\n    const size = Math.min(value.byteLength - offset, MAX_CHUNK_SIZE);\n    const buffer = value.buffer.slice(offset, offset + size);\n    offset += buffer.byteLength;\n    yield new Uint8Array(buffer);\n  }\n}\nasync function* readStream(readable) {\n  const reader = readable.getReader();\n  while (true) {\n    const { done, value } = await reader.read();\n    if (done) {\n      break;\n    }\n    yield value;\n  }\n}\nasync function* chunkStream(stream) {\n  for await (const value of stream) {\n    yield* clonePart(value);\n  }\n}\nvar getStreamIterator = (source) => {\n  if (isAsyncIterable(source)) {\n    return chunkStream(source);\n  }\n  if (isFunction(source.getReader)) {\n    return chunkStream(readStream(source));\n  }\n  throw new TypeError(\n    \"Unsupported data source: Expected either ReadableStream or async iterable.\"\n  );\n};\nasync function* consumeNodeBlob(blob) {\n  let position = 0;\n  while (position !== blob.size) {\n    const chunk = blob.slice(\n      position,\n      Math.min(blob.size, position + MAX_CHUNK_SIZE)\n    );\n    const buffer = await chunk.arrayBuffer();\n    position += buffer.byteLength;\n    yield new Uint8Array(buffer);\n  }\n}\nasync function* consumeBlobParts(parts, clone = false) {\n  for (const part of parts) {\n    if (ArrayBuffer.isView(part)) {\n      if (clone) {\n        yield* clonePart(part);\n      } else {\n        yield part;\n      }\n    } else if (isFunction(part.stream)) {\n      yield* getStreamIterator(part.stream());\n    } else {\n      yield* consumeNodeBlob(part);\n    }\n  }\n}\nfunction* sliceBlob(blobParts, blobSize, start = 0, end) {\n  end ??= blobSize;\n  let relativeStart = start < 0 ? Math.max(blobSize + start, 0) : Math.min(start, blobSize);\n  let relativeEnd = end < 0 ? Math.max(blobSize + end, 0) : Math.min(end, blobSize);\n  const span = Math.max(relativeEnd - relativeStart, 0);\n  let added = 0;\n  for (const part of blobParts) {\n    if (added >= span) {\n      break;\n    }\n    const partSize = ArrayBuffer.isView(part) ? part.byteLength : part.size;\n    if (relativeStart && partSize <= relativeStart) {\n      relativeStart -= partSize;\n      relativeEnd -= partSize;\n    } else {\n      let chunk;\n      if (ArrayBuffer.isView(part)) {\n        chunk = part.subarray(relativeStart, Math.min(partSize, relativeEnd));\n        added += chunk.byteLength;\n      } else {\n        chunk = part.slice(relativeStart, Math.min(partSize, relativeEnd));\n        added += chunk.size;\n      }\n      relativeEnd -= partSize;\n      relativeStart = 0;\n      yield chunk;\n    }\n  }\n}\n\n// src/Blob.ts\nvar _parts, _type, _size;\nvar _Blob = class _Blob {\n  /**\n   * Returns a new [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob) object.\n   * The content of the blob consists of the concatenation of the values given in the parameter array.\n   *\n   * @param blobParts An `Array` strings, or [`ArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer), [`ArrayBufferView`](https://developer.mozilla.org/en-US/docs/Web/API/ArrayBufferView), [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob) objects, or a mix of any of such objects, that will be put inside the [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob).\n   * @param options An optional object of type `BlobPropertyBag`.\n   */\n  constructor(blobParts = [], options = {}) {\n    /**\n     * An `Array` of [`ArrayBufferView`](https://developer.mozilla.org/en-US/docs/Web/API/ArrayBufferView) or [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob) objects, or a mix of any of such objects, that will be put inside the [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob).\n     */\n    __privateAdd(this, _parts, []);\n    /**\n     * Returns the [`MIME type`](https://developer.mozilla.org/en-US/docs/Glossary/MIME_type) of the [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob) or [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File).\n     */\n    __privateAdd(this, _type, \"\");\n    /**\n     * Returns the size of the [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob) or [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File) in bytes.\n     */\n    __privateAdd(this, _size, 0);\n    options ??= {};\n    if (typeof blobParts !== \"object\" || blobParts === null) {\n      throw new TypeError(\n        \"Failed to construct 'Blob': The provided value cannot be converted to a sequence.\"\n      );\n    }\n    if (!isFunction(blobParts[Symbol.iterator])) {\n      throw new TypeError(\n        \"Failed to construct 'Blob': The object must have a callable @@iterator property.\"\n      );\n    }\n    if (typeof options !== \"object\" && !isFunction(options)) {\n      throw new TypeError(\n        \"Failed to construct 'Blob': parameter 2 cannot convert to dictionary.\"\n      );\n    }\n    const encoder = new TextEncoder();\n    for (const raw of blobParts) {\n      let part;\n      if (ArrayBuffer.isView(raw)) {\n        part = new Uint8Array(raw.buffer.slice(\n          raw.byteOffset,\n          raw.byteOffset + raw.byteLength\n        ));\n      } else if (raw instanceof ArrayBuffer) {\n        part = new Uint8Array(raw.slice(0));\n      } else if (raw instanceof _Blob) {\n        part = raw;\n      } else {\n        part = encoder.encode(String(raw));\n      }\n      __privateSet(this, _size, __privateGet(this, _size) + (ArrayBuffer.isView(part) ? part.byteLength : part.size));\n      __privateGet(this, _parts).push(part);\n    }\n    const type = options.type === void 0 ? \"\" : String(options.type);\n    __privateSet(this, _type, /^[\\x20-\\x7E]*$/.test(type) ? type : \"\");\n  }\n  static [Symbol.hasInstance](value) {\n    return Boolean(\n      value && typeof value === \"object\" && isFunction(value.constructor) && (isFunction(value.stream) || isFunction(value.arrayBuffer)) && /^(Blob|File)$/.test(value[Symbol.toStringTag])\n    );\n  }\n  /**\n   * Returns the [`MIME type`](https://developer.mozilla.org/en-US/docs/Glossary/MIME_type) of the [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob) or [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File).\n   */\n  get type() {\n    return __privateGet(this, _type);\n  }\n  /**\n   * Returns the size of the [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob) or [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File) in bytes.\n   */\n  get size() {\n    return __privateGet(this, _size);\n  }\n  /**\n   * Creates and returns a new [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob) object which contains data from a subset of the blob on which it's called.\n   *\n   * @param start An index into the Blob indicating the first byte to include in the new Blob. If you specify a negative value, it's treated as an offset from the end of the Blob toward the beginning. For example, -10 would be the 10th from last byte in the Blob. The default value is 0. If you specify a value for start that is larger than the size of the source Blob, the returned Blob has size 0 and contains no data.\n   * @param end An index into the Blob indicating the first byte that will *not* be included in the new Blob (i.e. the byte exactly at this index is not included). If you specify a negative value, it's treated as an offset from the end of the Blob toward the beginning. For example, -10 would be the 10th from last byte in the Blob. The default value is size.\n   * @param contentType The content type to assign to the new Blob; this will be the value of its type property. The default value is an empty string.\n   */\n  slice(start, end, contentType) {\n    return new _Blob(sliceBlob(__privateGet(this, _parts), this.size, start, end), {\n      type: contentType\n    });\n  }\n  /**\n   * Returns a [`Promise`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) that resolves with a string containing the contents of the blob, interpreted as UTF-8.\n   */\n  async text() {\n    const decoder = new TextDecoder();\n    let result = \"\";\n    for await (const chunk of consumeBlobParts(__privateGet(this, _parts))) {\n      result += decoder.decode(chunk, { stream: true });\n    }\n    result += decoder.decode();\n    return result;\n  }\n  /**\n   * Returns a [`Promise`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) that resolves with the contents of the blob as binary data contained in an [`ArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer).\n   */\n  async arrayBuffer() {\n    const view = new Uint8Array(this.size);\n    let offset = 0;\n    for await (const chunk of consumeBlobParts(__privateGet(this, _parts))) {\n      view.set(chunk, offset);\n      offset += chunk.length;\n    }\n    return view.buffer;\n  }\n  /**\n   * Returns a [`ReadableStream`](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream) which upon reading returns the data contained within the [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob).\n   */\n  stream() {\n    const iterator = consumeBlobParts(__privateGet(this, _parts), true);\n    return new ReadableStream({\n      async pull(controller) {\n        const { value, done } = await iterator.next();\n        if (done) {\n          return queueMicrotask(() => controller.close());\n        }\n        controller.enqueue(value);\n      },\n      async cancel() {\n        await iterator.return();\n      }\n    });\n  }\n  get [Symbol.toStringTag]() {\n    return \"Blob\";\n  }\n};\n_parts = new WeakMap();\n_type = new WeakMap();\n_size = new WeakMap();\nvar Blob = _Blob;\nObject.defineProperties(Blob.prototype, {\n  type: { enumerable: true },\n  size: { enumerable: true },\n  slice: { enumerable: true },\n  stream: { enumerable: true },\n  text: { enumerable: true },\n  arrayBuffer: { enumerable: true }\n});\n\n// src/isBlob.ts\nvar isBlob = (value) => value instanceof Blob;\n\n// src/File.ts\nvar _name, _lastModified;\nvar File = class extends Blob {\n  /**\n   * Creates a new File instance.\n   *\n   * @param fileBits An `Array` strings, or [`ArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer), [`ArrayBufferView`](https://developer.mozilla.org/en-US/docs/Web/API/ArrayBufferView), [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob) objects, or a mix of any of such objects, that will be put inside the [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File).\n   * @param name The name of the file.\n   * @param options An options object containing optional attributes for the file.\n   */\n  constructor(fileBits, name, options = {}) {\n    super(fileBits, options);\n    /**\n     * Returns the name of the file referenced by the File object.\n     */\n    __privateAdd(this, _name, void 0);\n    /**\n     * The last modified date of the file as the number of milliseconds since the Unix epoch (January 1, 1970 at midnight). Files without a known last modified date return the current date.\n     */\n    __privateAdd(this, _lastModified, 0);\n    if (arguments.length < 2) {\n      throw new TypeError(\n        `Failed to construct 'File': 2 arguments required, but only ${arguments.length} present.`\n      );\n    }\n    __privateSet(this, _name, String(name));\n    const lastModified = options.lastModified === void 0 ? Date.now() : Number(options.lastModified);\n    if (!Number.isNaN(lastModified)) {\n      __privateSet(this, _lastModified, lastModified);\n    }\n  }\n  static [Symbol.hasInstance](value) {\n    return value instanceof Blob && value[Symbol.toStringTag] === \"File\" && typeof value.name === \"string\";\n  }\n  /**\n   * Name of the file referenced by the File object.\n   */\n  get name() {\n    return __privateGet(this, _name);\n  }\n  /* c8 ignore next 3 */\n  get webkitRelativePath() {\n    return \"\";\n  }\n  /**\n   * The last modified date of the file as the number of milliseconds since the Unix epoch (January 1, 1970 at midnight). Files without a known last modified date return the current date.\n   */\n  get lastModified() {\n    return __privateGet(this, _lastModified);\n  }\n  get [Symbol.toStringTag]() {\n    return \"File\";\n  }\n};\n_name = new WeakMap();\n_lastModified = new WeakMap();\n\n// src/isFile.ts\nvar isFile = (value) => value instanceof File;\n\n// src/FormData.ts\nvar _entries, _setEntry, setEntry_fn;\nvar FormData = class {\n  constructor() {\n    __privateAdd(this, _setEntry);\n    /**\n     * Stores internal data for every entry\n     */\n    __privateAdd(this, _entries, /* @__PURE__ */ new Map());\n  }\n  static [Symbol.hasInstance](value) {\n    if (!value) {\n      return false;\n    }\n    const val = value;\n    return Boolean(\n      isFunction(val.constructor) && val[Symbol.toStringTag] === \"FormData\" && isFunction(val.append) && isFunction(val.set) && isFunction(val.get) && isFunction(val.getAll) && isFunction(val.has) && isFunction(val.delete) && isFunction(val.entries) && isFunction(val.values) && isFunction(val.keys) && isFunction(val[Symbol.iterator]) && isFunction(val.forEach)\n    );\n  }\n  /**\n   * Appends a new value onto an existing key inside a FormData object,\n   * or adds the key if it does not already exist.\n   *\n   * The difference between `set()` and `append()` is that if the specified key already exists, `set()` will overwrite all existing values with the new one, whereas `append()` will append the new value onto the end of the existing set of values.\n   *\n   * @param name The name of the field whose data is contained in `value`.\n   * @param value The field's value. This can be [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob)\n    or [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File). If none of these are specified the value is converted to a string.\n   * @param fileName The filename reported to the server, when a Blob or File is passed as the second parameter. The default filename for Blob objects is \"blob\". The default filename for File objects is the file's filename.\n   */\n  append(name, value, fileName) {\n    __privateMethod(this, _setEntry, setEntry_fn).call(this, {\n      name,\n      fileName,\n      append: true,\n      rawValue: value,\n      argsLength: arguments.length\n    });\n  }\n  /**\n   * Set a new value for an existing key inside FormData,\n   * or add the new field if it does not already exist.\n   *\n   * @param name The name of the field whose data is contained in `value`.\n   * @param value The field's value. This can be [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob)\n    or [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File). If none of these are specified the value is converted to a string.\n   * @param fileName The filename reported to the server, when a Blob or File is passed as the second parameter. The default filename for Blob objects is \"blob\". The default filename for File objects is the file's filename.\n   *\n   */\n  set(name, value, fileName) {\n    __privateMethod(this, _setEntry, setEntry_fn).call(this, {\n      name,\n      fileName,\n      append: false,\n      rawValue: value,\n      argsLength: arguments.length\n    });\n  }\n  /**\n   * Returns the first value associated with a given key from within a `FormData` object.\n   * If you expect multiple values and want all of them, use the `getAll()` method instead.\n   *\n   * @param {string} name A name of the value you want to retrieve.\n   *\n   * @returns A `FormDataEntryValue` containing the value. If the key doesn't exist, the method returns null.\n   */\n  get(name) {\n    const field = __privateGet(this, _entries).get(String(name));\n    if (!field) {\n      return null;\n    }\n    return field[0];\n  }\n  /**\n   * Returns all the values associated with a given key from within a `FormData` object.\n   *\n   * @param {string} name A name of the value you want to retrieve.\n   *\n   * @returns An array of `FormDataEntryValue` whose key matches the value passed in the `name` parameter. If the key doesn't exist, the method returns an empty list.\n   */\n  getAll(name) {\n    const field = __privateGet(this, _entries).get(String(name));\n    if (!field) {\n      return [];\n    }\n    return field.slice();\n  }\n  /**\n   * Returns a boolean stating whether a `FormData` object contains a certain key.\n   *\n   * @param name A string representing the name of the key you want to test for.\n   *\n   * @return A boolean value.\n   */\n  has(name) {\n    return __privateGet(this, _entries).has(String(name));\n  }\n  /**\n   * Deletes a key and its value(s) from a `FormData` object.\n   *\n   * @param name The name of the key you want to delete.\n   */\n  delete(name) {\n    __privateGet(this, _entries).delete(String(name));\n  }\n  /**\n   * Returns an [`iterator`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols) allowing to go through all keys contained in this `FormData` object.\n   * Each key is a `string`.\n   */\n  *keys() {\n    for (const key of __privateGet(this, _entries).keys()) {\n      yield key;\n    }\n  }\n  /**\n   * Returns an [`iterator`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols) allowing to go through the `FormData` key/value pairs.\n   * The key of each pair is a string; the value is a [`FormDataValue`](https://developer.mozilla.org/en-US/docs/Web/API/FormDataEntryValue).\n   */\n  *entries() {\n    for (const name of this.keys()) {\n      const values = this.getAll(name);\n      for (const value of values) {\n        yield [name, value];\n      }\n    }\n  }\n  /**\n   * Returns an [`iterator`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols) allowing to go through all values contained in this object `FormData` object.\n   * Each value is a [`FormDataValue`](https://developer.mozilla.org/en-US/docs/Web/API/FormDataEntryValue).\n   */\n  *values() {\n    for (const [, value] of this) {\n      yield value;\n    }\n  }\n  /**\n   * An alias for FormData#entries()\n   */\n  [Symbol.iterator]() {\n    return this.entries();\n  }\n  /**\n   * Executes given callback function for each field of the FormData instance\n   */\n  forEach(callback, thisArg) {\n    for (const [name, value] of this) {\n      callback.call(thisArg, value, name, this);\n    }\n  }\n  get [Symbol.toStringTag]() {\n    return \"FormData\";\n  }\n};\n_entries = new WeakMap();\n_setEntry = new WeakSet();\nsetEntry_fn = function({\n  name,\n  rawValue,\n  append,\n  fileName,\n  argsLength\n}) {\n  const methodName = append ? \"append\" : \"set\";\n  if (argsLength < 2) {\n    throw new TypeError(\n      `Failed to execute '${methodName}' on 'FormData': 2 arguments required, but only ${argsLength} present.`\n    );\n  }\n  name = String(name);\n  let value;\n  if (isFile(rawValue)) {\n    value = fileName === void 0 ? rawValue : new File([rawValue], fileName, {\n      // otherwise, create new File with given fileName\n      type: rawValue.type,\n      lastModified: rawValue.lastModified\n    });\n  } else if (isBlob(rawValue)) {\n    value = new File([rawValue], fileName === void 0 ? \"blob\" : fileName, {\n      type: rawValue.type\n    });\n  } else if (fileName) {\n    throw new TypeError(\n      `Failed to execute '${methodName}' on 'FormData': parameter 2 is not of type 'Blob'.`\n    );\n  } else {\n    value = String(rawValue);\n  }\n  const values = __privateGet(this, _entries).get(name);\n  if (!values) {\n    return void __privateGet(this, _entries).set(name, [value]);\n  }\n  if (!append) {\n    return void __privateGet(this, _entries).set(name, [value]);\n  }\n  values.push(value);\n};\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n/*! Based on fetch-blob. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> & David Frank */\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZm9ybWRhdGEtbm9kZS9saWIvZm9ybS1kYXRhLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQixhQUFhO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxrQkFBa0I7QUFDNUIsVUFBVSxrQkFBa0I7QUFDNUIsV0FBVyxrQkFBa0I7QUFDN0IsWUFBWSxrQkFBa0I7QUFDOUIsVUFBVSxrQkFBa0I7QUFDNUIsaUJBQWlCO0FBQ2pCLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLGtCQUFrQjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsV0FBVyxrREFBa0QsWUFBWTtBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0EsNEJBQTRCLFdBQVc7QUFDdkM7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxDQUlMO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZm9ybWRhdGEtbm9kZS9saWIvZm9ybS1kYXRhLmNqcz8zMzYxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0NvbW1vbkpTID0gKG1vZCkgPT4gX19jb3B5UHJvcHMoX19kZWZQcm9wKHt9LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KSwgbW9kKTtcbnZhciBfX2FjY2Vzc0NoZWNrID0gKG9iaiwgbWVtYmVyLCBtc2cpID0+IHtcbiAgaWYgKCFtZW1iZXIuaGFzKG9iaikpXG4gICAgdGhyb3cgVHlwZUVycm9yKFwiQ2Fubm90IFwiICsgbXNnKTtcbn07XG52YXIgX19wcml2YXRlR2V0ID0gKG9iaiwgbWVtYmVyLCBnZXR0ZXIpID0+IHtcbiAgX19hY2Nlc3NDaGVjayhvYmosIG1lbWJlciwgXCJyZWFkIGZyb20gcHJpdmF0ZSBmaWVsZFwiKTtcbiAgcmV0dXJuIGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiBtZW1iZXIuZ2V0KG9iaik7XG59O1xudmFyIF9fcHJpdmF0ZUFkZCA9IChvYmosIG1lbWJlciwgdmFsdWUpID0+IHtcbiAgaWYgKG1lbWJlci5oYXMob2JqKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoXCJDYW5ub3QgYWRkIHRoZSBzYW1lIHByaXZhdGUgbWVtYmVyIG1vcmUgdGhhbiBvbmNlXCIpO1xuICBtZW1iZXIgaW5zdGFuY2VvZiBXZWFrU2V0ID8gbWVtYmVyLmFkZChvYmopIDogbWVtYmVyLnNldChvYmosIHZhbHVlKTtcbn07XG52YXIgX19wcml2YXRlU2V0ID0gKG9iaiwgbWVtYmVyLCB2YWx1ZSwgc2V0dGVyKSA9PiB7XG4gIF9fYWNjZXNzQ2hlY2sob2JqLCBtZW1iZXIsIFwid3JpdGUgdG8gcHJpdmF0ZSBmaWVsZFwiKTtcbiAgc2V0dGVyID8gc2V0dGVyLmNhbGwob2JqLCB2YWx1ZSkgOiBtZW1iZXIuc2V0KG9iaiwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xudmFyIF9fcHJpdmF0ZU1ldGhvZCA9IChvYmosIG1lbWJlciwgbWV0aG9kKSA9PiB7XG4gIF9fYWNjZXNzQ2hlY2sob2JqLCBtZW1iZXIsIFwiYWNjZXNzIHByaXZhdGUgbWV0aG9kXCIpO1xuICByZXR1cm4gbWV0aG9kO1xufTtcblxuLy8gc3JjL2luZGV4LnRzXG52YXIgc3JjX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHNyY19leHBvcnRzLCB7XG4gIEJsb2I6ICgpID0+IEJsb2IsXG4gIEZpbGU6ICgpID0+IEZpbGUsXG4gIEZvcm1EYXRhOiAoKSA9PiBGb3JtRGF0YVxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fdG9Db21tb25KUyhzcmNfZXhwb3J0cyk7XG5cbi8vIHNyYy9pc0Z1bmN0aW9uLnRzXG52YXIgaXNGdW5jdGlvbiA9ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCI7XG5cbi8vIHNyYy9pc09iamVjdC50c1xudmFyIGlzT2JqZWN0ID0gKHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG5cbi8vIHNyYy9pc0FzeW5jSXRlcmFibGUudHNcbnZhciBpc0FzeW5jSXRlcmFibGUgPSAodmFsdWUpID0+IGlzT2JqZWN0KHZhbHVlKSAmJiBpc0Z1bmN0aW9uKHZhbHVlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSk7XG5cbi8vIHNyYy9ibG9iSGVscGVycy50c1xudmFyIE1BWF9DSFVOS19TSVpFID0gNjU1MzY7XG5hc3luYyBmdW5jdGlvbiogY2xvbmVQYXJ0KHZhbHVlKSB7XG4gIGlmICh2YWx1ZS5ieXRlTGVuZ3RoIDw9IE1BWF9DSFVOS19TSVpFKSB7XG4gICAgeWllbGQgdmFsdWU7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBvZmZzZXQgPSAwO1xuICB3aGlsZSAob2Zmc2V0IDwgdmFsdWUuYnl0ZUxlbmd0aCkge1xuICAgIGNvbnN0IHNpemUgPSBNYXRoLm1pbih2YWx1ZS5ieXRlTGVuZ3RoIC0gb2Zmc2V0LCBNQVhfQ0hVTktfU0laRSk7XG4gICAgY29uc3QgYnVmZmVyID0gdmFsdWUuYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgc2l6ZSk7XG4gICAgb2Zmc2V0ICs9IGJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgIHlpZWxkIG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uKiByZWFkU3RyZWFtKHJlYWRhYmxlKSB7XG4gIGNvbnN0IHJlYWRlciA9IHJlYWRhYmxlLmdldFJlYWRlcigpO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgaWYgKGRvbmUpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB5aWVsZCB2YWx1ZTtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24qIGNodW5rU3RyZWFtKHN0cmVhbSkge1xuICBmb3IgYXdhaXQgKGNvbnN0IHZhbHVlIG9mIHN0cmVhbSkge1xuICAgIHlpZWxkKiBjbG9uZVBhcnQodmFsdWUpO1xuICB9XG59XG52YXIgZ2V0U3RyZWFtSXRlcmF0b3IgPSAoc291cmNlKSA9PiB7XG4gIGlmIChpc0FzeW5jSXRlcmFibGUoc291cmNlKSkge1xuICAgIHJldHVybiBjaHVua1N0cmVhbShzb3VyY2UpO1xuICB9XG4gIGlmIChpc0Z1bmN0aW9uKHNvdXJjZS5nZXRSZWFkZXIpKSB7XG4gICAgcmV0dXJuIGNodW5rU3RyZWFtKHJlYWRTdHJlYW0oc291cmNlKSk7XG4gIH1cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICBcIlVuc3VwcG9ydGVkIGRhdGEgc291cmNlOiBFeHBlY3RlZCBlaXRoZXIgUmVhZGFibGVTdHJlYW0gb3IgYXN5bmMgaXRlcmFibGUuXCJcbiAgKTtcbn07XG5hc3luYyBmdW5jdGlvbiogY29uc3VtZU5vZGVCbG9iKGJsb2IpIHtcbiAgbGV0IHBvc2l0aW9uID0gMDtcbiAgd2hpbGUgKHBvc2l0aW9uICE9PSBibG9iLnNpemUpIHtcbiAgICBjb25zdCBjaHVuayA9IGJsb2Iuc2xpY2UoXG4gICAgICBwb3NpdGlvbixcbiAgICAgIE1hdGgubWluKGJsb2Iuc2l6ZSwgcG9zaXRpb24gKyBNQVhfQ0hVTktfU0laRSlcbiAgICApO1xuICAgIGNvbnN0IGJ1ZmZlciA9IGF3YWl0IGNodW5rLmFycmF5QnVmZmVyKCk7XG4gICAgcG9zaXRpb24gKz0gYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgeWllbGQgbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24qIGNvbnN1bWVCbG9iUGFydHMocGFydHMsIGNsb25lID0gZmFsc2UpIHtcbiAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnRzKSB7XG4gICAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhwYXJ0KSkge1xuICAgICAgaWYgKGNsb25lKSB7XG4gICAgICAgIHlpZWxkKiBjbG9uZVBhcnQocGFydCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB5aWVsZCBwYXJ0O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbihwYXJ0LnN0cmVhbSkpIHtcbiAgICAgIHlpZWxkKiBnZXRTdHJlYW1JdGVyYXRvcihwYXJ0LnN0cmVhbSgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgeWllbGQqIGNvbnN1bWVOb2RlQmxvYihwYXJ0KTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uKiBzbGljZUJsb2IoYmxvYlBhcnRzLCBibG9iU2l6ZSwgc3RhcnQgPSAwLCBlbmQpIHtcbiAgZW5kID8/PSBibG9iU2l6ZTtcbiAgbGV0IHJlbGF0aXZlU3RhcnQgPSBzdGFydCA8IDAgPyBNYXRoLm1heChibG9iU2l6ZSArIHN0YXJ0LCAwKSA6IE1hdGgubWluKHN0YXJ0LCBibG9iU2l6ZSk7XG4gIGxldCByZWxhdGl2ZUVuZCA9IGVuZCA8IDAgPyBNYXRoLm1heChibG9iU2l6ZSArIGVuZCwgMCkgOiBNYXRoLm1pbihlbmQsIGJsb2JTaXplKTtcbiAgY29uc3Qgc3BhbiA9IE1hdGgubWF4KHJlbGF0aXZlRW5kIC0gcmVsYXRpdmVTdGFydCwgMCk7XG4gIGxldCBhZGRlZCA9IDA7XG4gIGZvciAoY29uc3QgcGFydCBvZiBibG9iUGFydHMpIHtcbiAgICBpZiAoYWRkZWQgPj0gc3Bhbikge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNvbnN0IHBhcnRTaXplID0gQXJyYXlCdWZmZXIuaXNWaWV3KHBhcnQpID8gcGFydC5ieXRlTGVuZ3RoIDogcGFydC5zaXplO1xuICAgIGlmIChyZWxhdGl2ZVN0YXJ0ICYmIHBhcnRTaXplIDw9IHJlbGF0aXZlU3RhcnQpIHtcbiAgICAgIHJlbGF0aXZlU3RhcnQgLT0gcGFydFNpemU7XG4gICAgICByZWxhdGl2ZUVuZCAtPSBwYXJ0U2l6ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGNodW5rO1xuICAgICAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhwYXJ0KSkge1xuICAgICAgICBjaHVuayA9IHBhcnQuc3ViYXJyYXkocmVsYXRpdmVTdGFydCwgTWF0aC5taW4ocGFydFNpemUsIHJlbGF0aXZlRW5kKSk7XG4gICAgICAgIGFkZGVkICs9IGNodW5rLmJ5dGVMZW5ndGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaHVuayA9IHBhcnQuc2xpY2UocmVsYXRpdmVTdGFydCwgTWF0aC5taW4ocGFydFNpemUsIHJlbGF0aXZlRW5kKSk7XG4gICAgICAgIGFkZGVkICs9IGNodW5rLnNpemU7XG4gICAgICB9XG4gICAgICByZWxhdGl2ZUVuZCAtPSBwYXJ0U2l6ZTtcbiAgICAgIHJlbGF0aXZlU3RhcnQgPSAwO1xuICAgICAgeWllbGQgY2h1bms7XG4gICAgfVxuICB9XG59XG5cbi8vIHNyYy9CbG9iLnRzXG52YXIgX3BhcnRzLCBfdHlwZSwgX3NpemU7XG52YXIgX0Jsb2IgPSBjbGFzcyBfQmxvYiB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IFtgQmxvYmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9CbG9iKSBvYmplY3QuXG4gICAqIFRoZSBjb250ZW50IG9mIHRoZSBibG9iIGNvbnNpc3RzIG9mIHRoZSBjb25jYXRlbmF0aW9uIG9mIHRoZSB2YWx1ZXMgZ2l2ZW4gaW4gdGhlIHBhcmFtZXRlciBhcnJheS5cbiAgICpcbiAgICogQHBhcmFtIGJsb2JQYXJ0cyBBbiBgQXJyYXlgIHN0cmluZ3MsIG9yIFtgQXJyYXlCdWZmZXJgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheUJ1ZmZlciksIFtgQXJyYXlCdWZmZXJWaWV3YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0FycmF5QnVmZmVyVmlldyksIFtgQmxvYmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9CbG9iKSBvYmplY3RzLCBvciBhIG1peCBvZiBhbnkgb2Ygc3VjaCBvYmplY3RzLCB0aGF0IHdpbGwgYmUgcHV0IGluc2lkZSB0aGUgW2BCbG9iYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Jsb2IpLlxuICAgKiBAcGFyYW0gb3B0aW9ucyBBbiBvcHRpb25hbCBvYmplY3Qgb2YgdHlwZSBgQmxvYlByb3BlcnR5QmFnYC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGJsb2JQYXJ0cyA9IFtdLCBvcHRpb25zID0ge30pIHtcbiAgICAvKipcbiAgICAgKiBBbiBgQXJyYXlgIG9mIFtgQXJyYXlCdWZmZXJWaWV3YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0FycmF5QnVmZmVyVmlldykgb3IgW2BCbG9iYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Jsb2IpIG9iamVjdHMsIG9yIGEgbWl4IG9mIGFueSBvZiBzdWNoIG9iamVjdHMsIHRoYXQgd2lsbCBiZSBwdXQgaW5zaWRlIHRoZSBbYEJsb2JgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQmxvYikuXG4gICAgICovXG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9wYXJ0cywgW10pO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFtgTUlNRSB0eXBlYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9HbG9zc2FyeS9NSU1FX3R5cGUpIG9mIHRoZSBbYEJsb2JgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQmxvYikgb3IgW2BGaWxlYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0ZpbGUpLlxuICAgICAqL1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfdHlwZSwgXCJcIik7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc2l6ZSBvZiB0aGUgW2BCbG9iYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Jsb2IpIG9yIFtgRmlsZWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9GaWxlKSBpbiBieXRlcy5cbiAgICAgKi9cbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX3NpemUsIDApO1xuICAgIG9wdGlvbnMgPz89IHt9O1xuICAgIGlmICh0eXBlb2YgYmxvYlBhcnRzICE9PSBcIm9iamVjdFwiIHx8IGJsb2JQYXJ0cyA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgXCJGYWlsZWQgdG8gY29uc3RydWN0ICdCbG9iJzogVGhlIHByb3ZpZGVkIHZhbHVlIGNhbm5vdCBiZSBjb252ZXJ0ZWQgdG8gYSBzZXF1ZW5jZS5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKCFpc0Z1bmN0aW9uKGJsb2JQYXJ0c1tTeW1ib2wuaXRlcmF0b3JdKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgXCJGYWlsZWQgdG8gY29uc3RydWN0ICdCbG9iJzogVGhlIG9iamVjdCBtdXN0IGhhdmUgYSBjYWxsYWJsZSBAQGl0ZXJhdG9yIHByb3BlcnR5LlwiXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT09IFwib2JqZWN0XCIgJiYgIWlzRnVuY3Rpb24ob3B0aW9ucykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgIFwiRmFpbGVkIHRvIGNvbnN0cnVjdCAnQmxvYic6IHBhcmFtZXRlciAyIGNhbm5vdCBjb252ZXJ0IHRvIGRpY3Rpb25hcnkuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICBmb3IgKGNvbnN0IHJhdyBvZiBibG9iUGFydHMpIHtcbiAgICAgIGxldCBwYXJ0O1xuICAgICAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhyYXcpKSB7XG4gICAgICAgIHBhcnQgPSBuZXcgVWludDhBcnJheShyYXcuYnVmZmVyLnNsaWNlKFxuICAgICAgICAgIHJhdy5ieXRlT2Zmc2V0LFxuICAgICAgICAgIHJhdy5ieXRlT2Zmc2V0ICsgcmF3LmJ5dGVMZW5ndGhcbiAgICAgICAgKSk7XG4gICAgICB9IGVsc2UgaWYgKHJhdyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgIHBhcnQgPSBuZXcgVWludDhBcnJheShyYXcuc2xpY2UoMCkpO1xuICAgICAgfSBlbHNlIGlmIChyYXcgaW5zdGFuY2VvZiBfQmxvYikge1xuICAgICAgICBwYXJ0ID0gcmF3O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFydCA9IGVuY29kZXIuZW5jb2RlKFN0cmluZyhyYXcpKTtcbiAgICAgIH1cbiAgICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfc2l6ZSwgX19wcml2YXRlR2V0KHRoaXMsIF9zaXplKSArIChBcnJheUJ1ZmZlci5pc1ZpZXcocGFydCkgPyBwYXJ0LmJ5dGVMZW5ndGggOiBwYXJ0LnNpemUpKTtcbiAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfcGFydHMpLnB1c2gocGFydCk7XG4gICAgfVxuICAgIGNvbnN0IHR5cGUgPSBvcHRpb25zLnR5cGUgPT09IHZvaWQgMCA/IFwiXCIgOiBTdHJpbmcob3B0aW9ucy50eXBlKTtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX3R5cGUsIC9eW1xceDIwLVxceDdFXSokLy50ZXN0KHR5cGUpID8gdHlwZSA6IFwiXCIpO1xuICB9XG4gIHN0YXRpYyBbU3ltYm9sLmhhc0luc3RhbmNlXSh2YWx1ZSkge1xuICAgIHJldHVybiBCb29sZWFuKFxuICAgICAgdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIGlzRnVuY3Rpb24odmFsdWUuY29uc3RydWN0b3IpICYmIChpc0Z1bmN0aW9uKHZhbHVlLnN0cmVhbSkgfHwgaXNGdW5jdGlvbih2YWx1ZS5hcnJheUJ1ZmZlcikpICYmIC9eKEJsb2J8RmlsZSkkLy50ZXN0KHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10pXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgW2BNSU1FIHR5cGVgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0dsb3NzYXJ5L01JTUVfdHlwZSkgb2YgdGhlIFtgQmxvYmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9CbG9iKSBvciBbYEZpbGVgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRmlsZSkuXG4gICAqL1xuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIF90eXBlKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc2l6ZSBvZiB0aGUgW2BCbG9iYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Jsb2IpIG9yIFtgRmlsZWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9GaWxlKSBpbiBieXRlcy5cbiAgICovXG4gIGdldCBzaXplKCkge1xuICAgIHJldHVybiBfX3ByaXZhdGVHZXQodGhpcywgX3NpemUpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgbmV3IFtgQmxvYmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9CbG9iKSBvYmplY3Qgd2hpY2ggY29udGFpbnMgZGF0YSBmcm9tIGEgc3Vic2V0IG9mIHRoZSBibG9iIG9uIHdoaWNoIGl0J3MgY2FsbGVkLlxuICAgKlxuICAgKiBAcGFyYW0gc3RhcnQgQW4gaW5kZXggaW50byB0aGUgQmxvYiBpbmRpY2F0aW5nIHRoZSBmaXJzdCBieXRlIHRvIGluY2x1ZGUgaW4gdGhlIG5ldyBCbG9iLiBJZiB5b3Ugc3BlY2lmeSBhIG5lZ2F0aXZlIHZhbHVlLCBpdCdzIHRyZWF0ZWQgYXMgYW4gb2Zmc2V0IGZyb20gdGhlIGVuZCBvZiB0aGUgQmxvYiB0b3dhcmQgdGhlIGJlZ2lubmluZy4gRm9yIGV4YW1wbGUsIC0xMCB3b3VsZCBiZSB0aGUgMTB0aCBmcm9tIGxhc3QgYnl0ZSBpbiB0aGUgQmxvYi4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgMC4gSWYgeW91IHNwZWNpZnkgYSB2YWx1ZSBmb3Igc3RhcnQgdGhhdCBpcyBsYXJnZXIgdGhhbiB0aGUgc2l6ZSBvZiB0aGUgc291cmNlIEJsb2IsIHRoZSByZXR1cm5lZCBCbG9iIGhhcyBzaXplIDAgYW5kIGNvbnRhaW5zIG5vIGRhdGEuXG4gICAqIEBwYXJhbSBlbmQgQW4gaW5kZXggaW50byB0aGUgQmxvYiBpbmRpY2F0aW5nIHRoZSBmaXJzdCBieXRlIHRoYXQgd2lsbCAqbm90KiBiZSBpbmNsdWRlZCBpbiB0aGUgbmV3IEJsb2IgKGkuZS4gdGhlIGJ5dGUgZXhhY3RseSBhdCB0aGlzIGluZGV4IGlzIG5vdCBpbmNsdWRlZCkuIElmIHlvdSBzcGVjaWZ5IGEgbmVnYXRpdmUgdmFsdWUsIGl0J3MgdHJlYXRlZCBhcyBhbiBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mIHRoZSBCbG9iIHRvd2FyZCB0aGUgYmVnaW5uaW5nLiBGb3IgZXhhbXBsZSwgLTEwIHdvdWxkIGJlIHRoZSAxMHRoIGZyb20gbGFzdCBieXRlIGluIHRoZSBCbG9iLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBzaXplLlxuICAgKiBAcGFyYW0gY29udGVudFR5cGUgVGhlIGNvbnRlbnQgdHlwZSB0byBhc3NpZ24gdG8gdGhlIG5ldyBCbG9iOyB0aGlzIHdpbGwgYmUgdGhlIHZhbHVlIG9mIGl0cyB0eXBlIHByb3BlcnR5LiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBhbiBlbXB0eSBzdHJpbmcuXG4gICAqL1xuICBzbGljZShzdGFydCwgZW5kLCBjb250ZW50VHlwZSkge1xuICAgIHJldHVybiBuZXcgX0Jsb2Ioc2xpY2VCbG9iKF9fcHJpdmF0ZUdldCh0aGlzLCBfcGFydHMpLCB0aGlzLnNpemUsIHN0YXJ0LCBlbmQpLCB7XG4gICAgICB0eXBlOiBjb250ZW50VHlwZVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgW2BQcm9taXNlYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUHJvbWlzZSkgdGhhdCByZXNvbHZlcyB3aXRoIGEgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIGNvbnRlbnRzIG9mIHRoZSBibG9iLCBpbnRlcnByZXRlZCBhcyBVVEYtOC5cbiAgICovXG4gIGFzeW5jIHRleHQoKSB7XG4gICAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgY29uc3VtZUJsb2JQYXJ0cyhfX3ByaXZhdGVHZXQodGhpcywgX3BhcnRzKSkpIHtcbiAgICAgIHJlc3VsdCArPSBkZWNvZGVyLmRlY29kZShjaHVuaywgeyBzdHJlYW06IHRydWUgfSk7XG4gICAgfVxuICAgIHJlc3VsdCArPSBkZWNvZGVyLmRlY29kZSgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBbYFByb21pc2VgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9Qcm9taXNlKSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIGNvbnRlbnRzIG9mIHRoZSBibG9iIGFzIGJpbmFyeSBkYXRhIGNvbnRhaW5lZCBpbiBhbiBbYEFycmF5QnVmZmVyYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXlCdWZmZXIpLlxuICAgKi9cbiAgYXN5bmMgYXJyYXlCdWZmZXIoKSB7XG4gICAgY29uc3QgdmlldyA9IG5ldyBVaW50OEFycmF5KHRoaXMuc2l6ZSk7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBjb25zdW1lQmxvYlBhcnRzKF9fcHJpdmF0ZUdldCh0aGlzLCBfcGFydHMpKSkge1xuICAgICAgdmlldy5zZXQoY2h1bmssIG9mZnNldCk7XG4gICAgICBvZmZzZXQgKz0gY2h1bmsubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gdmlldy5idWZmZXI7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBbYFJlYWRhYmxlU3RyZWFtYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1JlYWRhYmxlU3RyZWFtKSB3aGljaCB1cG9uIHJlYWRpbmcgcmV0dXJucyB0aGUgZGF0YSBjb250YWluZWQgd2l0aGluIHRoZSBbYEJsb2JgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQmxvYikuXG4gICAqL1xuICBzdHJlYW0oKSB7XG4gICAgY29uc3QgaXRlcmF0b3IgPSBjb25zdW1lQmxvYlBhcnRzKF9fcHJpdmF0ZUdldCh0aGlzLCBfcGFydHMpLCB0cnVlKTtcbiAgICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgIGFzeW5jIHB1bGwoY29udHJvbGxlcikge1xuICAgICAgICBjb25zdCB7IHZhbHVlLCBkb25lIH0gPSBhd2FpdCBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgcmV0dXJuIHF1ZXVlTWljcm90YXNrKCgpID0+IGNvbnRyb2xsZXIuY2xvc2UoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHZhbHVlKTtcbiAgICAgIH0sXG4gICAgICBhc3luYyBjYW5jZWwoKSB7XG4gICAgICAgIGF3YWl0IGl0ZXJhdG9yLnJldHVybigpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcbiAgICByZXR1cm4gXCJCbG9iXCI7XG4gIH1cbn07XG5fcGFydHMgPSBuZXcgV2Vha01hcCgpO1xuX3R5cGUgPSBuZXcgV2Vha01hcCgpO1xuX3NpemUgPSBuZXcgV2Vha01hcCgpO1xudmFyIEJsb2IgPSBfQmxvYjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEJsb2IucHJvdG90eXBlLCB7XG4gIHR5cGU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICBzaXplOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgc2xpY2U6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICBzdHJlYW06IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICB0ZXh0OiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgYXJyYXlCdWZmZXI6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XG59KTtcblxuLy8gc3JjL2lzQmxvYi50c1xudmFyIGlzQmxvYiA9ICh2YWx1ZSkgPT4gdmFsdWUgaW5zdGFuY2VvZiBCbG9iO1xuXG4vLyBzcmMvRmlsZS50c1xudmFyIF9uYW1lLCBfbGFzdE1vZGlmaWVkO1xudmFyIEZpbGUgPSBjbGFzcyBleHRlbmRzIEJsb2Ige1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBGaWxlIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0gZmlsZUJpdHMgQW4gYEFycmF5YCBzdHJpbmdzLCBvciBbYEFycmF5QnVmZmVyYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXlCdWZmZXIpLCBbYEFycmF5QnVmZmVyVmlld2BdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BcnJheUJ1ZmZlclZpZXcpLCBbYEJsb2JgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQmxvYikgb2JqZWN0cywgb3IgYSBtaXggb2YgYW55IG9mIHN1Y2ggb2JqZWN0cywgdGhhdCB3aWxsIGJlIHB1dCBpbnNpZGUgdGhlIFtgRmlsZWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9GaWxlKS5cbiAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIGZpbGUuXG4gICAqIEBwYXJhbSBvcHRpb25zIEFuIG9wdGlvbnMgb2JqZWN0IGNvbnRhaW5pbmcgb3B0aW9uYWwgYXR0cmlidXRlcyBmb3IgdGhlIGZpbGUuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihmaWxlQml0cywgbmFtZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIoZmlsZUJpdHMsIG9wdGlvbnMpO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG5hbWUgb2YgdGhlIGZpbGUgcmVmZXJlbmNlZCBieSB0aGUgRmlsZSBvYmplY3QuXG4gICAgICovXG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9uYW1lLCB2b2lkIDApO1xuICAgIC8qKlxuICAgICAqIFRoZSBsYXN0IG1vZGlmaWVkIGRhdGUgb2YgdGhlIGZpbGUgYXMgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgc2luY2UgdGhlIFVuaXggZXBvY2ggKEphbnVhcnkgMSwgMTk3MCBhdCBtaWRuaWdodCkuIEZpbGVzIHdpdGhvdXQgYSBrbm93biBsYXN0IG1vZGlmaWVkIGRhdGUgcmV0dXJuIHRoZSBjdXJyZW50IGRhdGUuXG4gICAgICovXG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9sYXN0TW9kaWZpZWQsIDApO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgYEZhaWxlZCB0byBjb25zdHJ1Y3QgJ0ZpbGUnOiAyIGFyZ3VtZW50cyByZXF1aXJlZCwgYnV0IG9ubHkgJHthcmd1bWVudHMubGVuZ3RofSBwcmVzZW50LmBcbiAgICAgICk7XG4gICAgfVxuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfbmFtZSwgU3RyaW5nKG5hbWUpKTtcbiAgICBjb25zdCBsYXN0TW9kaWZpZWQgPSBvcHRpb25zLmxhc3RNb2RpZmllZCA9PT0gdm9pZCAwID8gRGF0ZS5ub3coKSA6IE51bWJlcihvcHRpb25zLmxhc3RNb2RpZmllZCk7XG4gICAgaWYgKCFOdW1iZXIuaXNOYU4obGFzdE1vZGlmaWVkKSkge1xuICAgICAgX19wcml2YXRlU2V0KHRoaXMsIF9sYXN0TW9kaWZpZWQsIGxhc3RNb2RpZmllZCk7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBbU3ltYm9sLmhhc0luc3RhbmNlXSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIEJsb2IgJiYgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gXCJGaWxlXCIgJiYgdHlwZW9mIHZhbHVlLm5hbWUgPT09IFwic3RyaW5nXCI7XG4gIH1cbiAgLyoqXG4gICAqIE5hbWUgb2YgdGhlIGZpbGUgcmVmZXJlbmNlZCBieSB0aGUgRmlsZSBvYmplY3QuXG4gICAqL1xuICBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIF9uYW1lKTtcbiAgfVxuICAvKiBjOCBpZ25vcmUgbmV4dCAzICovXG4gIGdldCB3ZWJraXRSZWxhdGl2ZVBhdGgoKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBsYXN0IG1vZGlmaWVkIGRhdGUgb2YgdGhlIGZpbGUgYXMgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgc2luY2UgdGhlIFVuaXggZXBvY2ggKEphbnVhcnkgMSwgMTk3MCBhdCBtaWRuaWdodCkuIEZpbGVzIHdpdGhvdXQgYSBrbm93biBsYXN0IG1vZGlmaWVkIGRhdGUgcmV0dXJuIHRoZSBjdXJyZW50IGRhdGUuXG4gICAqL1xuICBnZXQgbGFzdE1vZGlmaWVkKCkge1xuICAgIHJldHVybiBfX3ByaXZhdGVHZXQodGhpcywgX2xhc3RNb2RpZmllZCk7XG4gIH1cbiAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgIHJldHVybiBcIkZpbGVcIjtcbiAgfVxufTtcbl9uYW1lID0gbmV3IFdlYWtNYXAoKTtcbl9sYXN0TW9kaWZpZWQgPSBuZXcgV2Vha01hcCgpO1xuXG4vLyBzcmMvaXNGaWxlLnRzXG52YXIgaXNGaWxlID0gKHZhbHVlKSA9PiB2YWx1ZSBpbnN0YW5jZW9mIEZpbGU7XG5cbi8vIHNyYy9Gb3JtRGF0YS50c1xudmFyIF9lbnRyaWVzLCBfc2V0RW50cnksIHNldEVudHJ5X2ZuO1xudmFyIEZvcm1EYXRhID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX3NldEVudHJ5KTtcbiAgICAvKipcbiAgICAgKiBTdG9yZXMgaW50ZXJuYWwgZGF0YSBmb3IgZXZlcnkgZW50cnlcbiAgICAgKi9cbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2VudHJpZXMsIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICB9XG4gIHN0YXRpYyBbU3ltYm9sLmhhc0luc3RhbmNlXSh2YWx1ZSkge1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgdmFsID0gdmFsdWU7XG4gICAgcmV0dXJuIEJvb2xlYW4oXG4gICAgICBpc0Z1bmN0aW9uKHZhbC5jb25zdHJ1Y3RvcikgJiYgdmFsW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09IFwiRm9ybURhdGFcIiAmJiBpc0Z1bmN0aW9uKHZhbC5hcHBlbmQpICYmIGlzRnVuY3Rpb24odmFsLnNldCkgJiYgaXNGdW5jdGlvbih2YWwuZ2V0KSAmJiBpc0Z1bmN0aW9uKHZhbC5nZXRBbGwpICYmIGlzRnVuY3Rpb24odmFsLmhhcykgJiYgaXNGdW5jdGlvbih2YWwuZGVsZXRlKSAmJiBpc0Z1bmN0aW9uKHZhbC5lbnRyaWVzKSAmJiBpc0Z1bmN0aW9uKHZhbC52YWx1ZXMpICYmIGlzRnVuY3Rpb24odmFsLmtleXMpICYmIGlzRnVuY3Rpb24odmFsW1N5bWJvbC5pdGVyYXRvcl0pICYmIGlzRnVuY3Rpb24odmFsLmZvckVhY2gpXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogQXBwZW5kcyBhIG5ldyB2YWx1ZSBvbnRvIGFuIGV4aXN0aW5nIGtleSBpbnNpZGUgYSBGb3JtRGF0YSBvYmplY3QsXG4gICAqIG9yIGFkZHMgdGhlIGtleSBpZiBpdCBkb2VzIG5vdCBhbHJlYWR5IGV4aXN0LlxuICAgKlxuICAgKiBUaGUgZGlmZmVyZW5jZSBiZXR3ZWVuIGBzZXQoKWAgYW5kIGBhcHBlbmQoKWAgaXMgdGhhdCBpZiB0aGUgc3BlY2lmaWVkIGtleSBhbHJlYWR5IGV4aXN0cywgYHNldCgpYCB3aWxsIG92ZXJ3cml0ZSBhbGwgZXhpc3RpbmcgdmFsdWVzIHdpdGggdGhlIG5ldyBvbmUsIHdoZXJlYXMgYGFwcGVuZCgpYCB3aWxsIGFwcGVuZCB0aGUgbmV3IHZhbHVlIG9udG8gdGhlIGVuZCBvZiB0aGUgZXhpc3Rpbmcgc2V0IG9mIHZhbHVlcy5cbiAgICpcbiAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIGZpZWxkIHdob3NlIGRhdGEgaXMgY29udGFpbmVkIGluIGB2YWx1ZWAuXG4gICAqIEBwYXJhbSB2YWx1ZSBUaGUgZmllbGQncyB2YWx1ZS4gVGhpcyBjYW4gYmUgW2BCbG9iYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Jsb2IpXG4gICAgb3IgW2BGaWxlYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0ZpbGUpLiBJZiBub25lIG9mIHRoZXNlIGFyZSBzcGVjaWZpZWQgdGhlIHZhbHVlIGlzIGNvbnZlcnRlZCB0byBhIHN0cmluZy5cbiAgICogQHBhcmFtIGZpbGVOYW1lIFRoZSBmaWxlbmFtZSByZXBvcnRlZCB0byB0aGUgc2VydmVyLCB3aGVuIGEgQmxvYiBvciBGaWxlIGlzIHBhc3NlZCBhcyB0aGUgc2Vjb25kIHBhcmFtZXRlci4gVGhlIGRlZmF1bHQgZmlsZW5hbWUgZm9yIEJsb2Igb2JqZWN0cyBpcyBcImJsb2JcIi4gVGhlIGRlZmF1bHQgZmlsZW5hbWUgZm9yIEZpbGUgb2JqZWN0cyBpcyB0aGUgZmlsZSdzIGZpbGVuYW1lLlxuICAgKi9cbiAgYXBwZW5kKG5hbWUsIHZhbHVlLCBmaWxlTmFtZSkge1xuICAgIF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfc2V0RW50cnksIHNldEVudHJ5X2ZuKS5jYWxsKHRoaXMsIHtcbiAgICAgIG5hbWUsXG4gICAgICBmaWxlTmFtZSxcbiAgICAgIGFwcGVuZDogdHJ1ZSxcbiAgICAgIHJhd1ZhbHVlOiB2YWx1ZSxcbiAgICAgIGFyZ3NMZW5ndGg6IGFyZ3VtZW50cy5sZW5ndGhcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU2V0IGEgbmV3IHZhbHVlIGZvciBhbiBleGlzdGluZyBrZXkgaW5zaWRlIEZvcm1EYXRhLFxuICAgKiBvciBhZGQgdGhlIG5ldyBmaWVsZCBpZiBpdCBkb2VzIG5vdCBhbHJlYWR5IGV4aXN0LlxuICAgKlxuICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgZmllbGQgd2hvc2UgZGF0YSBpcyBjb250YWluZWQgaW4gYHZhbHVlYC5cbiAgICogQHBhcmFtIHZhbHVlIFRoZSBmaWVsZCdzIHZhbHVlLiBUaGlzIGNhbiBiZSBbYEJsb2JgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQmxvYilcbiAgICBvciBbYEZpbGVgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRmlsZSkuIElmIG5vbmUgb2YgdGhlc2UgYXJlIHNwZWNpZmllZCB0aGUgdmFsdWUgaXMgY29udmVydGVkIHRvIGEgc3RyaW5nLlxuICAgKiBAcGFyYW0gZmlsZU5hbWUgVGhlIGZpbGVuYW1lIHJlcG9ydGVkIHRvIHRoZSBzZXJ2ZXIsIHdoZW4gYSBCbG9iIG9yIEZpbGUgaXMgcGFzc2VkIGFzIHRoZSBzZWNvbmQgcGFyYW1ldGVyLiBUaGUgZGVmYXVsdCBmaWxlbmFtZSBmb3IgQmxvYiBvYmplY3RzIGlzIFwiYmxvYlwiLiBUaGUgZGVmYXVsdCBmaWxlbmFtZSBmb3IgRmlsZSBvYmplY3RzIGlzIHRoZSBmaWxlJ3MgZmlsZW5hbWUuXG4gICAqXG4gICAqL1xuICBzZXQobmFtZSwgdmFsdWUsIGZpbGVOYW1lKSB7XG4gICAgX19wcml2YXRlTWV0aG9kKHRoaXMsIF9zZXRFbnRyeSwgc2V0RW50cnlfZm4pLmNhbGwodGhpcywge1xuICAgICAgbmFtZSxcbiAgICAgIGZpbGVOYW1lLFxuICAgICAgYXBwZW5kOiBmYWxzZSxcbiAgICAgIHJhd1ZhbHVlOiB2YWx1ZSxcbiAgICAgIGFyZ3NMZW5ndGg6IGFyZ3VtZW50cy5sZW5ndGhcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZmlyc3QgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIGEgZ2l2ZW4ga2V5IGZyb20gd2l0aGluIGEgYEZvcm1EYXRhYCBvYmplY3QuXG4gICAqIElmIHlvdSBleHBlY3QgbXVsdGlwbGUgdmFsdWVzIGFuZCB3YW50IGFsbCBvZiB0aGVtLCB1c2UgdGhlIGBnZXRBbGwoKWAgbWV0aG9kIGluc3RlYWQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEEgbmFtZSBvZiB0aGUgdmFsdWUgeW91IHdhbnQgdG8gcmV0cmlldmUuXG4gICAqXG4gICAqIEByZXR1cm5zIEEgYEZvcm1EYXRhRW50cnlWYWx1ZWAgY29udGFpbmluZyB0aGUgdmFsdWUuIElmIHRoZSBrZXkgZG9lc24ndCBleGlzdCwgdGhlIG1ldGhvZCByZXR1cm5zIG51bGwuXG4gICAqL1xuICBnZXQobmFtZSkge1xuICAgIGNvbnN0IGZpZWxkID0gX19wcml2YXRlR2V0KHRoaXMsIF9lbnRyaWVzKS5nZXQoU3RyaW5nKG5hbWUpKTtcbiAgICBpZiAoIWZpZWxkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGZpZWxkWzBdO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGFsbCB0aGUgdmFsdWVzIGFzc29jaWF0ZWQgd2l0aCBhIGdpdmVuIGtleSBmcm9tIHdpdGhpbiBhIGBGb3JtRGF0YWAgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBBIG5hbWUgb2YgdGhlIHZhbHVlIHlvdSB3YW50IHRvIHJldHJpZXZlLlxuICAgKlxuICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiBgRm9ybURhdGFFbnRyeVZhbHVlYCB3aG9zZSBrZXkgbWF0Y2hlcyB0aGUgdmFsdWUgcGFzc2VkIGluIHRoZSBgbmFtZWAgcGFyYW1ldGVyLiBJZiB0aGUga2V5IGRvZXNuJ3QgZXhpc3QsIHRoZSBtZXRob2QgcmV0dXJucyBhbiBlbXB0eSBsaXN0LlxuICAgKi9cbiAgZ2V0QWxsKG5hbWUpIHtcbiAgICBjb25zdCBmaWVsZCA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfZW50cmllcykuZ2V0KFN0cmluZyhuYW1lKSk7XG4gICAgaWYgKCFmaWVsZCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICByZXR1cm4gZmllbGQuc2xpY2UoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIGJvb2xlYW4gc3RhdGluZyB3aGV0aGVyIGEgYEZvcm1EYXRhYCBvYmplY3QgY29udGFpbnMgYSBjZXJ0YWluIGtleS5cbiAgICpcbiAgICogQHBhcmFtIG5hbWUgQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBuYW1lIG9mIHRoZSBrZXkgeW91IHdhbnQgdG8gdGVzdCBmb3IuXG4gICAqXG4gICAqIEByZXR1cm4gQSBib29sZWFuIHZhbHVlLlxuICAgKi9cbiAgaGFzKG5hbWUpIHtcbiAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIF9lbnRyaWVzKS5oYXMoU3RyaW5nKG5hbWUpKTtcbiAgfVxuICAvKipcbiAgICogRGVsZXRlcyBhIGtleSBhbmQgaXRzIHZhbHVlKHMpIGZyb20gYSBgRm9ybURhdGFgIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIGtleSB5b3Ugd2FudCB0byBkZWxldGUuXG4gICAqL1xuICBkZWxldGUobmFtZSkge1xuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfZW50cmllcykuZGVsZXRlKFN0cmluZyhuYW1lKSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gW2BpdGVyYXRvcmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0l0ZXJhdGlvbl9wcm90b2NvbHMpIGFsbG93aW5nIHRvIGdvIHRocm91Z2ggYWxsIGtleXMgY29udGFpbmVkIGluIHRoaXMgYEZvcm1EYXRhYCBvYmplY3QuXG4gICAqIEVhY2gga2V5IGlzIGEgYHN0cmluZ2AuXG4gICAqL1xuICAqa2V5cygpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBfX3ByaXZhdGVHZXQodGhpcywgX2VudHJpZXMpLmtleXMoKSkge1xuICAgICAgeWllbGQga2V5O1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhbiBbYGl0ZXJhdG9yYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvSXRlcmF0aW9uX3Byb3RvY29scykgYWxsb3dpbmcgdG8gZ28gdGhyb3VnaCB0aGUgYEZvcm1EYXRhYCBrZXkvdmFsdWUgcGFpcnMuXG4gICAqIFRoZSBrZXkgb2YgZWFjaCBwYWlyIGlzIGEgc3RyaW5nOyB0aGUgdmFsdWUgaXMgYSBbYEZvcm1EYXRhVmFsdWVgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRm9ybURhdGFFbnRyeVZhbHVlKS5cbiAgICovXG4gICplbnRyaWVzKCkge1xuICAgIGZvciAoY29uc3QgbmFtZSBvZiB0aGlzLmtleXMoKSkge1xuICAgICAgY29uc3QgdmFsdWVzID0gdGhpcy5nZXRBbGwobmFtZSk7XG4gICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgICB5aWVsZCBbbmFtZSwgdmFsdWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhbiBbYGl0ZXJhdG9yYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvSXRlcmF0aW9uX3Byb3RvY29scykgYWxsb3dpbmcgdG8gZ28gdGhyb3VnaCBhbGwgdmFsdWVzIGNvbnRhaW5lZCBpbiB0aGlzIG9iamVjdCBgRm9ybURhdGFgIG9iamVjdC5cbiAgICogRWFjaCB2YWx1ZSBpcyBhIFtgRm9ybURhdGFWYWx1ZWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Gb3JtRGF0YUVudHJ5VmFsdWUpLlxuICAgKi9cbiAgKnZhbHVlcygpIHtcbiAgICBmb3IgKGNvbnN0IFssIHZhbHVlXSBvZiB0aGlzKSB7XG4gICAgICB5aWVsZCB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEFuIGFsaWFzIGZvciBGb3JtRGF0YSNlbnRyaWVzKClcbiAgICovXG4gIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHJldHVybiB0aGlzLmVudHJpZXMoKTtcbiAgfVxuICAvKipcbiAgICogRXhlY3V0ZXMgZ2l2ZW4gY2FsbGJhY2sgZnVuY3Rpb24gZm9yIGVhY2ggZmllbGQgb2YgdGhlIEZvcm1EYXRhIGluc3RhbmNlXG4gICAqL1xuICBmb3JFYWNoKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgZm9yIChjb25zdCBbbmFtZSwgdmFsdWVdIG9mIHRoaXMpIHtcbiAgICAgIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgdmFsdWUsIG5hbWUsIHRoaXMpO1xuICAgIH1cbiAgfVxuICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgcmV0dXJuIFwiRm9ybURhdGFcIjtcbiAgfVxufTtcbl9lbnRyaWVzID0gbmV3IFdlYWtNYXAoKTtcbl9zZXRFbnRyeSA9IG5ldyBXZWFrU2V0KCk7XG5zZXRFbnRyeV9mbiA9IGZ1bmN0aW9uKHtcbiAgbmFtZSxcbiAgcmF3VmFsdWUsXG4gIGFwcGVuZCxcbiAgZmlsZU5hbWUsXG4gIGFyZ3NMZW5ndGhcbn0pIHtcbiAgY29uc3QgbWV0aG9kTmFtZSA9IGFwcGVuZCA/IFwiYXBwZW5kXCIgOiBcInNldFwiO1xuICBpZiAoYXJnc0xlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgYEZhaWxlZCB0byBleGVjdXRlICcke21ldGhvZE5hbWV9JyBvbiAnRm9ybURhdGEnOiAyIGFyZ3VtZW50cyByZXF1aXJlZCwgYnV0IG9ubHkgJHthcmdzTGVuZ3RofSBwcmVzZW50LmBcbiAgICApO1xuICB9XG4gIG5hbWUgPSBTdHJpbmcobmFtZSk7XG4gIGxldCB2YWx1ZTtcbiAgaWYgKGlzRmlsZShyYXdWYWx1ZSkpIHtcbiAgICB2YWx1ZSA9IGZpbGVOYW1lID09PSB2b2lkIDAgPyByYXdWYWx1ZSA6IG5ldyBGaWxlKFtyYXdWYWx1ZV0sIGZpbGVOYW1lLCB7XG4gICAgICAvLyBvdGhlcndpc2UsIGNyZWF0ZSBuZXcgRmlsZSB3aXRoIGdpdmVuIGZpbGVOYW1lXG4gICAgICB0eXBlOiByYXdWYWx1ZS50eXBlLFxuICAgICAgbGFzdE1vZGlmaWVkOiByYXdWYWx1ZS5sYXN0TW9kaWZpZWRcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChpc0Jsb2IocmF3VmFsdWUpKSB7XG4gICAgdmFsdWUgPSBuZXcgRmlsZShbcmF3VmFsdWVdLCBmaWxlTmFtZSA9PT0gdm9pZCAwID8gXCJibG9iXCIgOiBmaWxlTmFtZSwge1xuICAgICAgdHlwZTogcmF3VmFsdWUudHlwZVxuICAgIH0pO1xuICB9IGVsc2UgaWYgKGZpbGVOYW1lKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgIGBGYWlsZWQgdG8gZXhlY3V0ZSAnJHttZXRob2ROYW1lfScgb24gJ0Zvcm1EYXRhJzogcGFyYW1ldGVyIDIgaXMgbm90IG9mIHR5cGUgJ0Jsb2InLmBcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIHZhbHVlID0gU3RyaW5nKHJhd1ZhbHVlKTtcbiAgfVxuICBjb25zdCB2YWx1ZXMgPSBfX3ByaXZhdGVHZXQodGhpcywgX2VudHJpZXMpLmdldChuYW1lKTtcbiAgaWYgKCF2YWx1ZXMpIHtcbiAgICByZXR1cm4gdm9pZCBfX3ByaXZhdGVHZXQodGhpcywgX2VudHJpZXMpLnNldChuYW1lLCBbdmFsdWVdKTtcbiAgfVxuICBpZiAoIWFwcGVuZCkge1xuICAgIHJldHVybiB2b2lkIF9fcHJpdmF0ZUdldCh0aGlzLCBfZW50cmllcykuc2V0KG5hbWUsIFt2YWx1ZV0pO1xuICB9XG4gIHZhbHVlcy5wdXNoKHZhbHVlKTtcbn07XG4vLyBBbm5vdGF0ZSB0aGUgQ29tbW9uSlMgZXhwb3J0IG5hbWVzIGZvciBFU00gaW1wb3J0IGluIG5vZGU6XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgQmxvYixcbiAgRmlsZSxcbiAgRm9ybURhdGFcbn0pO1xuLyohIEJhc2VkIG9uIGZldGNoLWJsb2IuIE1JVCBMaWNlbnNlLiBKaW1teSBXw6RydGluZyA8aHR0cHM6Ly9qaW1teS53YXJ0aW5nLnNlL29wZW5zb3VyY2U+ICYgRGF2aWQgRnJhbmsgKi9cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/formdata-node/lib/form-data.cjs\n");

/***/ })

};
;